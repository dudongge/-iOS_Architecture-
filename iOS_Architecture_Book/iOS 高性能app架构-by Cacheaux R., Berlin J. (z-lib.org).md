
目录

写在前面
需要必备的软硬件条件
资源代码和论坛
第一章 欢迎👏🏻
 即将来临的是什么 
这本书适合谁
下一章内容精彩预告

第二章  哪一种架构是适合我的
         确定要解决的问题
 提高团队开发速率&增强代码质量
问题检查
增加代码的敏捷性
架构模式概述
选择一个模式
模式实践
关键点

第三章 app例子-考拉(Koober)
koober
为什么选择koober
入门资源获取
本章关键点

第四章 对象&依赖
目标建立
行话学习
       依赖创建
       基本思考
为什么是这种架构
依赖模式
依赖注入
按需应变的方式
单容器方式
多层次容器结构设计
DI 理论在 iOSAPP中的应用
按需应变的方法的应用
工厂方式的应用
单容器方式的应用
多层次容器结构设计
关键点
下一章内容精彩预告

第五章 MVVM 架构
MVVM 是什么
容器视图
视图模型之间的通信
实战导引
iOSapp 理论实践
组合视图
实战导引
状态管理
关键点
MVVM 的利弊
下一章内容精彩预告

第六章 Redux架构
历史包袱
Redux 是什么
iOSapp理论实践
关键点
Redux利弊
下一章内容精彩预告

第七章  架构元素-第一部分
元素介绍
元素的基本概念
用户接口
交互响应者
关键点

第八章 架构元素-第二部分
观察者
用例
元素的优缺点
关键点
总结

写在前面
非常高兴您能看到这本大量机翻的外文书，我也是无意间看到这本书的，还有就是现在出去面试基本上都会问架构相关的东西，其实架构这玩意，大家都在用，只是平常很好考虑罢了，都说脱离了业务谈架构就是耍流氓，架构没有好坏，只有适合不适合，正如鲁迅叼着烟说：世上本无架构，代码写的多了，走在前面的人就总结出了架构。
另外，这本书页码不多--很好阅读，有代码注释，只是代码年久失修，但不影响阅读学习。
这本书主要是机翻，对英译汉有追求的人建议去读英文版，(https://ur.u1lib.org/book/5002805/90c154?dsource=recommend）需要翻墙，也可以在github上查看：(https://github.com/dudongge/iOS_Architecture)因为堂主英文不好。堂主对比了三家主流的翻译机器，（百度翻译，谷歌翻译，有道翻译），竟然有道翻译做的最好-不是打广告哈。
正值上海疫情期间，有家不能回，心情万分沮丧，正好蜗居在3平多的出租房里，把之前未做完的事情做完一下。也希望疫情快点过去吧。               
                                   																2022-04-11 上海出租屋
                                                         													东阁堂主

你需要准备的条件
如果要顺利完成这本书，需要具备以下条件：
Mac 系统版本在 macOS Mojave (10.14.3）或之后
Swift5：书中所有的工程都是用swift 5 来编写的
Xcode: 10.2版本或之后
如果你已经具备了以上的条件，那就愉快的开始吧，相信你会不虚此行。
授之以鱼，不如授之以鱼本书希望为开发者拓宽视野并了解架构，帮助他们如何构建稳		健且可维护的应用和sdk。
通过这本书，我们用一个虚构的app-Koober来带你深入研究不同的架构。每个章节前面会先解释每种架构背后的理论。章节的后半部分将引导您通过Koober了解应用程序如何利用该架构，以及在架构中是如何使用的。

资源代码和论坛
这本书为每个章节配备了详细的例子和代码，您可以动动手指在这里下载http://store.raywenderlich.com，当然为了百家争鸣，我们也为这本书设置了论坛http://forums.raywenderlich.com，在这里，您可以畅所欲言，当然也希望您为本书提供宝贵意见。


第一章  欢迎👏🏻
欢迎您来到高级iOS应用架构。本书旨在为你解释和展示当下最流行的架构应用。好了，小可爱，我们已经迫不及待的和您一起探索每个章节中涵盖的架构。
我们独爱这个主题。我们对架构情有独钟，因为架构解锁了团队快速成长和前进的能力。

内容提要
章节1-4 主要向您介绍本书涵盖的不同方面，我们建议在深入研究任何架构章节之前先阅读这些章节，万丈高楼平地起，打好基础是关键。
章节5-7是架构章节，一个章节，我们只探索一种架构，每个章节的架构都会追本溯源，然后进行详细的理论演练。每个架构章节的后半部分都集中于将该理论应用于iOS应用程序开发。在每一章的结尾都将介绍该体系结构的优缺点。此时您请随意按任何顺序阅读后面的章节。
本书中有许多架构没有涉及，因为我们想深入而不是广泛，诚然，我们也会在将来能完善更多的架构体系。

这本书为谁而写
如果您在用swift，那么恭喜您，这本书就是为您而写。本书中的内容假设读者熟悉设计模式和基本架构-譬如MVC和基本的架构概念，比如控制反转。
如果您是 Swift 新手，请查看 raywenderlich.com 的 Swift Apprentice 书；如需复习设计模式，请查看 raywenderlich.com 设计模式教程。

下一步
接下来的三章是介绍相关，读下他们，选择你最感兴趣的架构，并深入探究他们。
如果您不确定要探索哪些架构，我们建议您先阅读所有架构章节的理论部分，以确定哪些架构最适合您的需求。然后，您可以通过阅读您认为最吸引人的章节的 iOS 应用程序部分来深入了解。
笔者希望，在阅读完本书之后，您能将不同的应用程序架构应用到不同的项目中，从而提高团队快速、稳健地构建的能力。来，一起畅玩架构！

第二章  哪一种架构是适合我的

站在码农的十字路口，你可能会疑惑，那种架构方式适合我？实话实说，没有完美通用的app的架构。A架构适合M项目，但是并不适合你的项目。在为您和您的团队建立一个架构时，需要考虑许多不同的方面。那么本章节将带您一起探索那个架构最适合您的项目😏。
将您的应用代码库塑造成一个具有高内聚和有效性的架构需要做很多事情。万事开头难，应用程序代码库中的每个文件都在应用程序的架构中扮演着重要的角色。当然架构模式也有很多。不幸的是，大多数模式只触及表面，没有深入研究。另外，很多架构模式很相似，差别微乎其微。
以上所有的这些问题，导致我们很难将架构应用到实践中。幸运的是，您可以采取一些实用的步骤来确保你的架构是有效的，比如下面这些：
1.了解你的代码的当前状态-知己知彼。
2.找出确定想要解决的问题或想要改进的代码。
3.评估不同的架构体系模式.
4.在选择一种样式之前，多尝试一下其他的模式，要雨露均沾。
5.设置底线，定义应用程序的基线架构-铁血手腕。
6.实时回顾并确定您的架构方式是否有效地解决了您想要解决的问题。
7.日积月累，架构在你的项目中日益壮大，并根深蒂固。
大家看，选择体系架构模式并不是上述列表中的第一项，而实际情况是，使用架构模式解决的问题比选择那个架构模式更重要。花些时间来整理想要解决的问题，可以让您专注于架构中真正起作用的几个方面。有些问题是随着项目来的，但也有一些通用的问题可以通过良好的架构来解决。接下来的几节将详细讨论这些问题。

          确定要解决的问题
 在开始任何架构项目之前，首先应该确定并理解想要解决的哪些问题。这样才能知道架构可以帮你做些什么。良好的架构能够使您和您的团队在没有大量风险的情况下轻松而安全地更改代码，这难道不是很多码农期望的吗。对没有用到架构的代码更改是效率低且风险大。好的架构实践解决的两个主要问题是团队的开发速度过慢和代码质量健壮性。另外，好的架构还可以提高代码的复用性。下一节将介绍这两个主要问题，然后介绍下代码的复用性。

            提高团队速度和增强代码质量
一个好的应用程序架构能够让你在不牺牲质量的情况下更快地交付功能和修复错误，换言之，一个不太理想的体系结构会减慢您的团队的速度，并且使您的代码库很难在不破坏现有功能的情况下进行更改。知道了这些之后，就应该知道哪些问题会被发现，哪些问题能通过架构解决，下面这些问题出现时，将会导致拉低开发速度和降低代码健壮性:
1，我们的代码不好理解
2，修改程序代码后，有时会导致整个功能回归。
3，我的应用程序在运行时不够健壮。
4，代码不易复用。
5，更改细小的功能，就需要大量的代码重构。
6，团队成员之间会步调不一致互相抱怨。
7，代码不易单元测试。
8，团队很难将用户情景分解成任务。
9，项目编译时间过长。

理解根源
这些问题都可能由两个根本原因引起:高度相互依赖的代码和类型过大（类，结构体，协议等）。
在制定提高团队速度和增强代码质量的计划时，理解这些根本原因是很重要的。那么，这些根本原因到底是什么?你如何知道它们是否已经进入你的代码库?那就接着往下读。

高度相互依赖的代码
一个典型的代码库有大量的变量、对象和类型之间的相互依赖和连接，当一种类型的代码接触到其他具体类型(即非协议类型)时，代码变得高度相互依赖（类a和类b相互引用）。类型通常为了读写状态或为了调用方法而接触到其他类型。代码之间相互依赖很容易，所以我们很容易发现代码库有很多可见的全局对象。
代码没有封装，那依赖就会泛滥。代码库的各个部分耦合得越紧密，在更改代码时就越有可能出现意外的故障。这在拥有多个开发人员的大型团队中更加复杂，因为每个人都需要完全理解相互依赖关系，而这在非常大型的团队中可能是一项不可能完成的任务。

大型类型
大型类型是类、结构体、协议和枚举，它们有很长的公共接口，因为它们有很多公共方法和/或属性。它们的实现也很长，通常有数百甚至数千行代码。
向已有类型添加代码要比创建新类型容易得多。创建新类型时，我们需要思考：这种类型应该负责什么，这种类型实例的生命周期（比如单例），现有的代码都能转向这个新的类型吗，如果这个新类型需要访问另一个类型持有的状态，该怎么办。
设计面向对象的体系需要时间，当你面临急需交付的压力时，做出这种权衡是很困难的。问题是，许多问题是由大型类型引起的——这些问题会降低您的速度，并影响您的代码质量。在下面的部分中，您将看到这些结果的示例。现在，只需知道将大型类型分解为较小类型是改进代码架构的一种好方法（就是代码拆解和细分）。现在，您已经熟悉了这些问题的根本原因，可以深入研究可能导致团队开发效率不高和代码质量低下的问题了。

代码晦涩难懂
不知道你有没有花点时间去弄清楚视图控制器是如何工作的？由于代码的文字属性，难以理解与生俱来。文件和类型之间的连接很难看到。对代码库中的各个部分是如何连接的有一个确定的理解，这将帮助您推断代码是如何工作的。搜嘎，应用的架构方式在代码的易读性方面的贡献日渐凸显。
体系架构可以通过几种方式影响可读性：
你的类中有多长的代码？
600行视图控制器代码是很难理解的。如果你所需要知道的只是一个按钮的功能，那么搜索600行视图控制器代码将花费大量宝贵的时间（俗称代码写的又臭又长，又被戏称💩山）。一个好的架构会将大块的代码分解成易于阅读和理解的小块、模块化的代码。架构希望局部封装的行为和状态，这样的代码就越容易阅读。想想你正在开发的应用。如果明天有新团队成员加入你的团队，并且需要理解单个视图控制器，那么开发者需要理解的应用程序代码的花费的时间百分比是多少。在评估架构体系在多大程度上帮助提高了代码的可读性时，这可以作为一个很好的参考标准。很不幸，大多数架构模式都没有充分强调这一点。值得肯定的是，该实践可以应用于几乎任何体系架构模式，所以这是架构的一个普遍的方面。

你的代码库有多少全局变量，有多少对象直接在另一个对象中实例化？
你的对象之间的直接依赖程度越高，你的对象对全局状态的依赖程度就越高，这样就会导致开发者在读取单个文件时获得的信息就越少。这使得我们很难知道一个文件中的变化会如何影响另一个文件中的代码（老代码不敢动）。这迫使开发人员通过Command-click（一步一步查看）将整个控制流程梳理通，这是很耗时的。与类大小类似，如今流行的架构模式没有充分强调仔细管理依赖关系。管理依赖关系是一个通用的方面，可以应用于任何架构体系模式。所以，我们将这方面应用到本书附带的每个架构代码示例中。我们也用了整整一章来讨论这个问题。您可以在第4章中阅读更多关于管理依赖项的内容。

你的视图控制器在你的应用程序的代码库中应该有什么不同
作为开发人员，包括将来的自己，都要花费大量的时间来研究不同的应用场景是否使用不同的架构模式来实现。人类大脑在识别模式方面非常出色，所以您可以通过确保您的代码库始终遵循类似的架构模式来利用此功能，具有一致的结构可以大大减少了理解代码所需的认知开销。反过来，开发人员会更愿意更改和改进应用程序代码库的旧部分，因为他们熟悉常见模式。
此外，使用一致的架构模式可以建立一些通用的词汇（行话），开发者直接使用相同的词汇可以帮助每个人轻松地讨论和理解彼此的代码。
以上只是架构影响代码可读性的几个方面，通过应用架构模式和概念来提高代码的可读性，可以帮助团队提高生产力，且可以避免一些未知的错误。

改变应用程序的代码库有时会导致回归
你有没有见过一个看似无害的小代码改变意外地破坏了应用程序中一些不相关的部分?这种情况发生的概率随着代码的增长和随时间的变化而增加。如果这个问题未被检查，有朝一日，你会重写整个应用（无法再维护了）,在敏捷开发中，开发人员经常更改代码，更是家常便饭。因此，构建能够适应变化的代码比以往任何时候都更加重要。
造成这个问题的主要体系架构原因是代码间高度依赖。假设你在修复一个内容视图控制器中的bug，这个视图控制器管理活动指示器的显示和动画。当视图控制器完成加载时，活动指示器应该停止动画，但是，改指示器还在动画，为了修复它，你可以通过停止动画来关闭指示器。这时就需要向内容视图控制器添加代码来关闭动画，然后交付上线。不久，您就会发现一个新的错误。指示器停止动画，但很快又开始动画😓，指示器是一个公共属性，也被一个容器视图控制器管理，在完成一些工作时，容器视图控制器错误地打开了指示器的动画，而它应该关闭它…但是它没有! 最终，这里的问题是指示器的控制没有封装在内容视图控制器中，在容器视图控制器，内容视图控制器和活动指示器之间有一个相互依赖关系。
在一个高度相互依赖的代码库中工作时，代码更改的影响不容易被发现。最理想情况下，您应该能够很容易地推断出您正在编辑的当前文件是如何连接到代码库的其余部分的。做到这一点的最好方法是限制对象依赖，并使所必需的依赖明显可见，大家都要知道。
这种情况确实会减慢团队的速度，因为任何时候任何功能的构建或任何bug的修复都有出错的可能，如果出现问题，可能需要所有人一起找出根本原因（最后指出是谁的锅）。在一个非常脆弱的代码库中，更改-中断-修复循环可能会滚雪球般失去控制，bug不断，将会花费您更多的时间去修补bug，而不是改进应用。这不仅是一个团队开发速率问题，也是一个代码质量问题。当代码之间的关联难以查看和理解时，向用户发送错误的可能性要高得多。难以理解的代码会导致代码在更改时很容易崩溃。总之，一个好的模块化架构可以帮助您避免在进行更改时意外引入错误。

应用程序在运行时不够健壮
应用程序可以是在复杂环境中运行，像多核编程和应用扩展共享数据这样的事情增加了构建iOS应用程序的复杂性，因此，应用程序容易出现难以诊断的问题，比如竞态条件和状态不一致。
例如，您可能会注意到许多崩溃报告是由于与某些可变状态相关联的竞态条件而产生的（多线程）。诊断和修复这种崩溃可能需要几天时间。足够多的这类问题会让团队陷入停滞，一些架构体系模式和概念试图通过设计规则来解决这类问题，这些规则充当保护栏杆，以帮助团队避免最常见的陷阱，帮你远离麻烦。因此，如果您发现自己工作在一个相当复杂的环境中，请尝试建立体系架构模式，作为管理复杂性的一种手段。你的应用越具有确定性，用户遭遇奇怪漏洞的可能性就越小，你和你的团队花在追踪这些奇怪漏洞上的时间也就越少。

代码不易复用
代码库的架构决定了可以重用多少代码，这个架构还决定了向现有代码添加新行为的容易程度。如果您觉得每次构建一个新功能时都必须一次又一次地做出类似的决定（重复做相同的东西），那么您可能想要关注这个问题。也就是说，如果您觉得每个功能都是从头开始构建的（考虑是不是可以复用）。
大型类型会妨碍代码的可重用性，例如，一个2,000行的大型类不太可能被重用（MD,我就遇到过😓），因为您可能只需要类的一部分。
   您需要的部分可能与类的其余部分紧密耦合，使得您需要的部分在没有类的其余部分的情况下无法使用，也就是说类型越小，责任越少，越有可能被重用。
如果不能重用任何代码，编写代码会花费更多的时间，如果您正在解决复杂的UI问题，这些问题可以用许多不同的方法来解决，那么花时间重构代码以使其可重用是有意义的。使代码可重用不仅可以帮助您更快地构建新的东西，还可以帮助您修改现有的功能。但是，如果您不需要重用您的大部分代码呢，例如，你可能不会从多个地方实例化大多数视图控制器，这一点很重要:可重用性不仅仅是能够重用代码。它还可以在改变应用功能时可以随意删除移动代码。所有东西的可重用性越高，就越容易将代码分散，而不需要进行冒险的重构。
当然，带有不可重用代码的代码库可能会导致代码质量问题。例如，假设在用户输入信息的几个屏幕中有字段验证逻辑。验证错误UI逻辑在每个屏幕的视图控制器中被复制，由于重复了类似的逻辑，可能每个屏幕显示的验证错误略有不同，从而导致不一致的用户体验，如果有人发现了一个错误，你必须找到所有显示验证错误的视图控制器，您可能会错过一个实例，并最终继续发布相同的bug……!这是最不愿意看见的。最终，让代码可重用可以让你获得一致的用户体验，并让你可以轻松调整应用程序的行为。

更改大量需要重构的代码
曾经多少次你认为改变一个小功能会很简单，但你却发现自己做了一个大的重构。架构模式不仅可以帮助您重用代码，还可以帮助您在不进行大规模重构的情况下替换部分代码。在一个架构良好的代码库中，您应该能够轻松地进行独立的更改，而不会影响代码库的其余部分。那么是什么让代码难以替换呢?是的，您猜对了:大型类型和高度相互依赖的代码。
更新代码中的类型以使其易于替换，这确实加快了团队的开发速度，因为它允许多人同时处理代码库的多个部分。

成员直接相互抱怨
应用程序的架构也会影响您与团队成员并行工作的容易程度，当一个代码库不适合并行的工作流时，团队成员要么会相互抱怨，要么就会无所事事，等待一个合适的时间重新开始提交代码。
理想情况下，代码库有足够小的单元，团队中的每个人都可以在构建特性时在单独的文件中编写代码。否则，您将遇到诸如合并冲突之类的问题，这些问题可能需要很长时间才能解决。例如，如果你的应用的主屏幕完全在一个视图控制器中实现，构建UI布局的开发者可能会与构建网络刷新的人发生冲突。当您可以作为一个团队开会并围绕构建功能的不同方面进行自我组织时，有人可以构建布局，有人可以构建网络，有人可以构建缓存，有人可以构建验证逻辑等等。好的架构使您能够做到这一点。这就并行开发吧。
如果多个开发人员正在构建相同的特性，只有较小的类型是不够的，因为一个开发人员正在构建的代码可能依赖于其他开发人员未编写的代码，虽然开发人员可以在等待其他开发人员的同时硬编码虚假数据，但如果他们事先就api达成一致，这样就可以加快开发进度。您可以为这些依赖项设计和编写协议，这样开发人员就可以调用尚未构建的功能。这使得开发人员可以编写单元测试，甚至是完整的实现，而无需在构建完所有系统后进行大规模的集成。同时，这也保证了UI代码不依赖于网络、缓存等实现细节。
蓦然回首，应用程序是由一到五人的团队开发的，而今，许多应用都是由20多名iOS开发者共同开发。有些甚至是由100多个开发者开发的。那些雇佣了大量开发人员的公司正在寻找一种方法，通过将开发人员组织成跨功能的团队来最大化大型开发团队的生产力。许多人称之为“团队模式”。“小队”模式是由Spotify推广的，随着团队和公司的成长，团队之间的协调需要花费大量的时间。一个团队的代码对另一个团队的代码的依赖程度越高，这些团队为了交付就必须相互依赖得越多，这样就使得开发人员之间混乱，步调不一致。这就是架构的意义所在。关键在于设计一个应用架构，让开发者能够独立地构建功能，将每个特性松散地合到单独的Swift模块中的架构。这为每个团队提供了一个容器，他们可以使用该容器去构建自己所需的功能。所以，小队可以更快地发布功能，因为这种架构给予小队快速行动所需的自主权。
总而言之，如果你的应用程序架构允许你的团队通过松散耦合层，这样你就可以轻松地并行化工作，那么你将能够更快地构建业务需求。

代码库不易单元测试
众所周知，代码很难进行单元测试，因为代码库通常由紧密耦合在一起的部分组成。这使得在测试期间不可能分离出不同的部分。譬如，一个视图控制器可以用CoreData持久化一些数据，因为持久化被嵌入到视图控制器中，所以持久化和视图控制器是紧密耦合的。这意味着你想单元测试视图控制器，不得不建立一个完整的CoreData堆栈。如果您的单元测试需要大量的设置，或者如果您的单元测试执行了无法控制的其他操作，如网络和持久性，那么您的应用程序的代码库可以从架构重构中受益，意味着需要代码重构了。

编译时间过长
在构建一个新功能时，你构建并运行应用的次数是多少，几十个或更多，对吧?长时间的编译确实会降低开发速度。一个快速的反馈循环能够真正加速事情的发展（反馈-改进）。这听起来不错，但是编译时间与架构有什么关系呢。模块化的应用架构可以帮助Xcode构建系统重新编译未更改的代码。
Swift语言的设计者在设计Swift语言时做了一个重大的决定。他们决定放弃使用头文件，他们这样做是为了减少重复，使语言更容易学习，因为Swift不使用头文件，所以当编译每个文件时，Swift编译器必须读取组成Swift模块的所有Swift文件。这意味着当你改变一个文件时，Swift编译器可能需要解析模块中的所有Swift文件，如果你在一个应用目标中有很多Swift文件，例如一个Swift模块，即使你做了一个小的更改，重新编译你的应用可能会花费一段时间。详细的工作原理超出了本书的范围，但是要知道Xcode的构建系统每年都在变得更加智能。从Xcode 10开始，Xcode有能力做一些增量编译。
尽管有这些改进，但把你的应用拆分成几个Swift模块可以加快你的构建时间。这是因为Xcode构建系统不需要重新编译那些Swift文件没有更改的模块。此外，将你的应用分解成多个模块会导致更小的模块，也就是说，模块中包含更少的Swift文件，这意味着Xcode构建系统需要做更少的工作来构建每个模块。支持多模块应用程序的架构可以帮助你加快构建时间，这样你就可以花更少的时间等待应用程序运行。
加快本地构建时间是非常好的，但是如果这还不够好，您可以通过使用可以使用分布式构建缓存的不同构建系统来进一步加快构建时间，（记得swift3.0时，曾经通过pod加静态库来减少编译时长）。构建系统，比如谷歌的Bazel，可以让你缓存、下载和重用在别人机器上编译的Swift模块，想象一下，你拉了一个请求分支，你只是拉了它，却发现应用的.ipa下载并安装到你的模拟器上，而不需要编译任何源代码，是不是很神奇，这一切都是因为你的一个同事已经构建了在这个pull request分支中找到的代码，还有什么比零编译时构建更好的呢?
只有当你拥有一个允许多模块Swift代码库的架构时，这些构建时间优势才有可能实现。

团队很难将用户故事分解成任务
一个好的体系架构甚至可以帮助您计划软件开发项目，将用户故事分解成任务是非常困难的，将用户故事分解成团队中每个人都能理解的任务更加困难。例如，如果你计划在一个单一视图控制器中实现一个特性，你将如何创建明确的任务？将类型划分为职责的应用程序架构时，创建了一个通用话数，大家都遵循并且能听懂。
通用行话使您能够与其他团队成员共同理解使用什么类型的对象来构建功能。您可以轻松地将用户描述分解为所需的不同类型的对象，例如，你可以将用户故事分解成构建UIView、UIViewController、用于网络连接的RemoteAPI、用于缓存的数据存储等任务。团队的自我组织越快，他们花在计划上的时间就越少，所以，他们就有更多的时间构建功能。

增加代码的灵活性
除了提高团队的速度和增强代码的质量之外，体系架构还可以提高代码的敏捷性。敏捷的代码可以很容易地修改以满足目标，而不需要大量重写。代码敏捷性为您带来了很大的灵活性。它使您能够快速响应技术领域的变化。它还使您能够快速响应用户需求的变化。当然如何知道代码是否不敏捷? 以及会面临什么问题？
以下是一些可以通过架构来解决的问题，而且可以增加代码的灵活性：
1，发现自己被一种技术束缚住了。
2，被迫在项目早期做出重大决定。
3，添加特性标志是困难的。
在本节中，将一一解答上述问题。

发现自己被一种技术束缚住了
您是否曾经需要计划一个大型迁移项目，将您的代码从一种技术迁移到另一种技术？或者您想要将代码从一种技术迁移到另一种技术，但由于工作量太大而无法实现？被技术所束缚会使功能开发停顿，并且会阻止你利用新技术所提供的好处。这个问题与移动开发特别相关，因为正如你所经历的那样，移动技术是不断变化的。例如，如果您使用Parse(一个曾经流行但现在已不复存在的移动后端)作为服务，那么您对这种痛苦非常了解。很多时候，您需要对这些更改做出快速响应。应用程序的架构可以帮助您做到这一点。
当你的高级类型(比如视图控制器)与低级系统实现紧密耦合时，你可能会被技术所束缚。当高级代码调用实现特定类型而不是调用协议类型时，就会发生这种情况。例如，如果你的视图控制器直接调用NSURLConnection，在ios7之前，那么你可能需要进入每个视图控制器并更新你的代码来使用NSURLSession。如果您有一个非常大的代码库，您可能会等到最后一分钟才迁移，因为所涉及的工作，这只是高级代码与低级系统紧密耦合的众多可能方式之一。
当您的高级类型依赖于特定的数据格式时，您也可能被锁定在一种技术中。在与服务器通信和持久化信息时，通常需要使用数据格式，服务器通信数据格式的情况是最棘手的，因为您可能无法控制服务器后端，构建和维护后端应用服务器的团队有一天可能会来找你，要求使用不同的数据格式，甚至是不同的网络范例，如GraphQL。
假设你的应用服务器今天在发送JSON，而此时视图控制器正在反序列化和序列化JSON，如果你的服务器团队决定使用不同的格式，比如Protocol Buffers，你可能需要重新实现每个单独的视图控制器。
虽然前面的示例有些直接，但数据格式问题可能更微妙一些，例如，我之前的一个项目中的聊天应用程序需要将聊天信息从聊天服务器中转到应用程序的UI。聊天消息使用XML编码。我们知道不能直接把XML传递给视图控制器，当然这还不够，聊天消息的结构由另一种称为XMPP的标准定义，我们可以很容易地以反映XMPP规范的方式对承载聊天消息的结构进行构建。我们决定基于聊天消息的外观属性对结构进行构建，这样我们的视图控制器就不会与聊天服务器技术紧密耦合。我们不想被限制在XMPP中。
这些只是您的体系结构可以将您锁定在技术或让您轻松切换到新技术的几种方式。

被迫在项目早期做出重大决定
开始一个新项目时，选择使用哪种技术是很诱人的。其中一些技术选择是重大决定，感觉就像单行道，选了之后就不好回头了。随着应用程序变得越来越复杂，开发人员发现自己需要做出更多的技术决策。你需要大量的技术去创造现代的iOS应用，如果能够在不需要预先做出所有重大决定的情况下就开始构建应用，那不是很好吗？你甚至会发现你根本不需要某种技术。一个好的体系结构允许您在最合适的时间做出技术决策。
数据库就是一个典型的例子，你曾经参与过CoreData对Realm的讨论吗?很多时候，这些讨论发生在编写一行代码之前。问题是，这些数据库技术增加了很多复杂性，而且，如果你很早就做了这个决定，很有可能你会被锁定在这些技术中。问题是，在项目开始的时候，你可能没有做这个决定所需的所有信息。在我之前的一个项目中，我们决定设计数据存储协议，并使用NSCoding将Objective-C对象序列化到磁盘。在我们有时间合并CoreData之前，我们将此作为一种临时措施。结果我们甚至不需要CoreData!最简单的解决方案就足够好了。我们最终将应用交付给了数百万用户，并且在持久性方面没有任何问题。
现在，我们需要一个像CoreData这样的数据库，关键在于，你可以让你的团队构建应用的重要部分，而无需事先做出重大决定。

添加特性标志是困难的
软件团队开始使用数据驱动和精益的方法来开发应用程序，为了采用这些方法，开发人员使用特性标记来测试A/B特性，并将未完成的特性关闭，你的应用程序的架构可以让你容易或困难地将特性标志合并到你的应用程序的代码库中。如果你的应用程序的代码库被分解成松散耦合的小块，你就可以很容易地添加功能标志。一个好的应用程序架构会给你在行为之间切换所需的灵活性，以及打开和关闭特定事物的灵活性。

测量体系结构模式
在您确定了想要解决的问题之后，下一步是调查体系结构模式，好消息是，有大量的架构模式可供选择。坏消息是，有大量的架构模式可供选择。大多数模式都非常相似，本节提供了一个指南，帮助您在探索现有体系结构模式时确定使用的顺序，当您阅读以下段落时，请记住，本书涵盖了提到的三个体系架构。在下一节中，您将了解为什么要将模式付诸实践。
由于UIKit在设计时考虑到模型视图控制器(MVC)，所以任何MVC以外的模式都需要被改造到UIKit中，因此，在研究模式时，MVC是一个很好的开始。
一旦你看了MVC，接下来要看的是任何MV模式，如MVVM和MVP。值得注意的例外是MVI;稍后你会明白为什么，MV-模式是想似的模式，因为这些模式与MVC非常相似，它们有模型和视图，所以它们很容易映射到大多数UIKit的MVC结构。在非mvc MV体系结构中，你必须弄清楚在你使用的任何MV模式中，如何将视图控制器连接到它们的等效类型。例如，当使用MVVM时，你必须弄清楚如何将视图模型映射到视图控制器。您可以在第5章中阅读更多关于MVVM的内容。
干净的架构和端口和适配器是下一个很好的地方，这些概念本身是非常高水平和抽象的。为了将Clean Architecture和Ports & Adapters应用到iOS应用开发中，你需要进行大量的阅读和思考。如果您有时间，我建议您在先沿着这条路线然后研究从这些概念派生的其他特定模式。
深入理解将帮助您调整任何派生模式。如果你想探索源自Clean architecture和Ports & Adapters的iOS架构模式，请查看VIPER和rib。干净的架构和端口&适配器模式非常适合有很多本地业务逻辑的应用程序，如果您的应用程序的表示量很大，并且没有大量的本地业务逻辑，那么这些模式可能不适合您。
接下来，我建议查看单个架构模式，这些模式都是关于响应式ui和状态管理的。这些可能是最难付诸实践的模式。然而，如果应用得好，就会得到很多保证，比如状态一致性，而这些保证是其他模式无法得到的。单向模式绝对值得考虑。如果你感兴趣，看看Flux, Redux, RxFeedback和Model-View-Intent (MVI)。Redux是我见过的在iOS应用开发中应用最多的单向模式。如果您想深入了解Redux，请参阅第6章。
所有这些模式的一个共同属性是它们定义的组件都是相互关联的。它们是相当不灵活的，也就是说，它们不是用来混合的。你可能会觉得你必须选择一种模式而不是另一种。这就是为什么我的合著者Josh和我决定提出另一种方法，我们称之为元素。
元素是一组较小的体系结构模式的集合，它们被设计成独立的。您可以采用一种模式、两种模式或所有模式。它们也被设计成一起工作。我们的目标是将我们所学到的所有架构模式应用到iOS上，并想出一种灵活的方法，让开发者能够在无需重构整个代码库的情况下应用一些内容。你可以在第7章和第8章读到所有关于元素的内容。
这让你可以鸟瞰一些模式，你可以用来塑造你的应用程序的架构。这绝不是一个全面的列表。新模式总是会出现，所以看看你是否能找到最适合你的模式是值得的。

模式选择
一旦熟悉了各种模式，您就会想要决定使用哪些模式，选择一个模式并不容易，因为我们倾向于推荐哪一种设计模式。老实说，你选择哪种模式并不重要，重要的是你如何将这种模式付诸实践。
我见过架构非常好的MVC iOS应用，也见过架构非常糟糕的MVVM iOS应用，反之亦然。视图模型可以和视图控制器一样庞大。例如，一个模型在任何MV-模式中到底是什么样子？在MV模式中设计模型层并不是一种单一的方法。不仅如此，大多数模式在设计时都没有考虑到移动应用程序——更不用说今天复杂的iOS环境了。因此，大多数模式只触及表面。因此，选择“正确的”模式不会自动产生一个架构良好的代码库。
希望这能给你一种自由的感觉!下次当您发现自己处于关于架构的激烈辩论中时，请记住模式本身并不那么重要。我并不是说模式一点都不重要，我只是说选择一个特定的模式并不是最重要的决定。您可以使用任何模式创建一个架构良好的应用程序。（脱离业务谈架构是不是耍流氓😀）。
决定使用哪种模式的最佳方法是在代码库中尝试几个模式，这将为您提供关于模式在多大程度上满足您的需求的最佳信息。尝试不同的模式时，不要害怕尝试每一种模式。此外，在网上搜索一下，看看其他人对你考虑的模式有什么可以参考的。
此外，不要忘记考虑人的因素。你的团队有多大?你的队友经验如何？你的队友最熟悉的模式是什么?你的截止日期有多紧？当然，还要考虑到技术方面的问题，比如，您希望在代码库中设计什么样的约束条件，如果你时间紧促，MVC可能是iOS应用开发的最佳选择，因为你不必花时间考虑如何将外部模式合并到UIKit的MVC结构中。
在尝试不同的模式时，是否有任何需要注意的“陷阱”？那是肯定的，这里有一些问题是基于我在尝试不同模式时所经历的一些痛点：
你最终会得到很多样板代码吗?如果是这样，那么该样板文件是否至少使代码更容易理解呢
你最后会得到很多只调用代理方法的空文件吗
模式是不是晦涩难懂
要应用模式，需要重构多少内容
模式是否添加了许多新概念和词汇
您需要导入一个库来使用该模式吗
      这些不一定是坏事，它们只是你在调查和比较不同模式时需要考虑的东西，另外，不要觉得你必须选择一个模式而不是另一个。即使这些模式不是设计为混合和匹配的，也没有理由不能组合它们。例如，如果您真的喜欢单向模式，但是您的代码库是使用MVVM构建的，那么您可以轻松地将MVVM层放在Redux之类的东西上。只要有你的视图模型调度行动，并有你的视图模型听Redux商店…如果这没有任何意义，不用担心。您将在第5章和第6章分别学习有关MVVM和Redux的所有内容。综上所述，架构与其说是科学，不如说是艺术。去尝试，学习和创造吧。没有正确的方法来做这件事。请记住，有许多好的架构方法，也有许多不太好的架构方法——但没有一种正确的方法。

将模式付诸实践
本书的其余部分都是关于将模式付诸实践的。我们目前涵盖了三种模式:MVVM、Redux和Elements。
你可能想知道为什么我们只涵盖了这么少的模式。记住，如何应用模式比选择哪种模式更重要。我们想带您深入了解应用模式。而且，我们不想回避真正应用中会遇到的那种复杂性。我们选择专注于其中的一些模式，而不是只泛泛而谈大量的模式。我们还想涵盖其他架构书籍中没有的材料。例如，许多模式忽略了应用程序架构的重要方面，比如导航。本书中的大多数模式章节都涉及导航，而不考虑模式的主要关注点。
您可能还想知道为什么我们选择这三个特定的模式，我们想从每个历史中涵盖一个模式。例如，MVVM来自于模式的MV集。Redux是一个单向模式。元素植根于干净的架构加上端口和适配器。我们计划在本书的未来版本中添加更多的模式。如果你想让我们介绍一个特定的模式，请在本书的论坛中告诉我们。
在下面的章节中，您将深入了解每个模式的细节。但是，您可能想知道，在将任何模式付诸实践时，应该寻找什么样的一般情况。这里有一些小的建议:
松散耦合的部分: 无论你使用的是MVC、MVVM、Redux、VIPER等，确保你的代码被分解成松散耦合的小部分
有凝聚力的类型: 确保你的类型具有高内聚性，也就是说，组成每个类型的属性和方法属于一起。如果您的小型类型具有非常集中的职责，那么您的类型可能表现出高凝聚力。
多模块的应用: 确保你的应用被分解成几个Swift模块.
对象的依赖关系: 确保你正在使用依赖注入容器和服务定位器等模式来管理对象依赖。第4章深入讨论了依赖注入。
这些都是架构真正起作用的方面。我们将在前面的章节和附带的示例代码中演示所有这些方面。

本章要点：
不存在完美的通用应用架构
您可以使用架构来提高团队的速度，增强代码的质量和提高代码的敏捷性
选择“正确”的体系结构模式并不能保证你的代码库将被良好的体系结构。将模式付诸实践比你选择哪种模式更重要，实践出真知。
您可以随意混合和匹配不同的架构模式
架构与其说是一门科学，不如说是一门艺术。去尝试，学习和创造吧


第三章 app实例：Koober

本章介绍了Koober，这是本书中使用的示例应用程序，您将探索组成应用程序的所有页面，以及它们如何一起工作。在本章的最后，您将快速浏览Xcode项目和源代码。每一章都附带了Koober的重新实现，这样您就可以比较和对比不同的架构。本书中的材料假设您已经很好地理解了示例应用程序，所以在深入阅读下面任何一章之前，请确保阅读本章节。

Koober
想象动物和人类是一样的世界。他们说着不同的语言，生活在不同的国家，去Mermaidbucks喝咖啡等等。在这个动物王国，智能手机刚刚首次进入市场。世界上所有的开发者都在竞相开发下一个大的应用。
澳大利亚的kangaroo🦘出租车行业是出圈的主要原因（就像滴滴，支不过这里是骑袋鼠）。乘客们厌倦了付现金，而且还得亲自走到街上招呼kangaroo🦘。另外，有些袋鼠跳得太高，让乘客头疼。乘客苦于没有办法给予反馈。悉尼的一个开发团队注意到了这一点，决定成立一家新的初创公司来开发Koober，这是下一个大型叫车应用程序。
Koober的工作原理和你在人类世界中可能熟悉的其他叫车应用程序一样。Koober拥有组成现代应用的常见组件，如启动、注册、登录、账户配置等。这里是所有屏幕的一个快速浏览。

启动
当你第一次打开应用程序时，你会看到启动屏幕。这个屏幕来去非常快，所以你可能看不到它。该应用程序正在确定用户在该屏幕出现时是否已登录。




欢迎
如果用户没有登录，应用程序会切换到欢迎屏幕



注册
从欢迎屏幕，您可以导航到注册屏幕，以创建一个新用户帐户


呼叫坐骑
一旦你注册了，你就进入了“打车”的应用流程。首先，应用程序确定你当前的物理位置。该位置被用作搭车的地点。Koober的用户定位系统总是返回澳大利亚的悉尼作为你的当前位置，所以你不必给出你的实际位置


然后，你会看到一张带有你的拾取地点注释的地图。在屏幕的顶部，有一个Where to?按钮导航到投递地点选择器
             

               
                落客位置拾取器是预先播种的位置。你也可以使用UISearchBar执行搜索。



一旦你选择了一个交付地点，你会被带回到地图屏幕，其中交付地点被标注，并且在屏幕的底部显示出行选项选择器。




你用选车工具选车。一个骑行选项指定了哪种动物会来接你。有些动物比其他动物能驮更多的骑手，例如，在悉尼，小袋鼠、大袋鼠和一般袋鼠为Koober提供服务。
小袋鼠、大袋鼠和袋鼠被认为是不同种类的袋鼠。这三种袋鼠的体型从最小到最大各不相同。这意味着袋鼠比小袋鼠能承受更多的重量，而且骑起来更贵。一旦您选择了一个乘坐选项，您可以确认您的新乘坐请求。这就是你koober平台搭车。



等待被接单
一旦你的新搭车请求被发送，应用程序就会把你带到等待搭车屏幕。你可以在这个屏幕上按下“开始新乘坐”按钮，开始一个新的乘坐请求

查看个人资料
您可以通过点击位于所有启动流程屏幕右上角的配置文件按钮来查看您的用户配置文件。

退出登录
您可以从个人资料页面退出应用程序。

登录
在你退出后，应用程序会显示欢迎屏幕，你可以在其中导航到登录页面。您可以随时登录johnny@gmail.com和密码。

为设么是Koober 这个应用
在规划这本书时，我们希望确保示例代码能够适用于实际的项目,我们从社区中听说，大多数架构筑书籍都过于简化了示例，让读者自己去弄清楚理论在现实世界中的应用。所以我们决定构建一个具有真实应用程序复杂性的完整应用程序，作为我们示例的基础。我们真的很喜欢叫车应用，因为叫车应用具有现实世界应用的所有复杂性，无需构建大量的页面和UI。
Koober在结合网络、持久性、身份验证等方面的同时演示架构理论。我们承认这个应用程序并没有涵盖我们读者的所有类型的项目，然而，我们希望每个人都能发现这些类型并且很容易融入到各种各样的项目中。
如果您在当前的项目中尝试了本书中的任何技术，请告诉我们它的进展情况!我们希望在这本书的论坛听到你的声音。

开始使用源代码
为了熟悉示例应用程序中的代码，本节将带你了解应用程序是如何启动的，以及在哪里可以找到初始视图控制器。本节使用示例应用程序的模型-视图-视图模型(MVVM)版本。在接下来的过程中，不要过于担心架构的理解，因为您将在第5章中探索MVVM。

启动顺序
当你第一次启动Koober时，你会看到两个页面:启动页面和欢迎页面。
启动页面由LaunchViewController实现，欢迎页面由WelcomeViewController实现。继续阅读，看看这些视图控制器是如何进入屏幕的。

视图控制器层次结构
Koober的根视图控制器是由MainViewController实现的，这是一个自定义的容器视图控制器，当应用程序启动时，MainViewController被安装。MainViewController通过将LaunchViewController呈现为一个子视图控制器来加载。当启动屏幕出现时，MainViewController和LaunchViewController组成了视图控制器层次结构

LaunchViewController然后确定用户是否已登录，当你第一次运行Koober时，用户不会被登录，所以MainViewController会从LaunchViewController导航到OnboardingViewController。
OnboardingViewController是一个UINavigationController的子类，它以呈现WelcomeViewController开始，当欢迎屏幕出现时，MainViewController, OnboardingViewController和WelcomeViewController组成了视图控制器层次结构。

好了，是时候真正的技术了， 启动Xcode查看一下源代码。

开放源代码
要查看Koober的源代码，请找到03-example-app/final/KooberApp目录，并打开KooberApp.xcodeproj。每章目录中都有不同版本的Koober。
一个单独的Xcode项目包含了Koober的所有源代码，并且这些源代码被组织成几个目标。
这里附上代码的地址 https://github.com/threadLord/AdvancedAppArchitecture (比较老)
 注：项目使用Carthage 管理三方库的。拉下项目，在根目录执行Carthage update --platform iOS，运行，把出错的屏蔽掉就可以运行成功。
 这有给新版本,https://github.com/lp-architecture/koober
另外还有SwiftUI版本的，代码不是很全，不过可以参考
附上地址：https://github.com/raywenderlich/swiftui-example-app-koober

Xcode项目目标
koober: 这是Koober的iOS应用目标，包含应用委托和其他应用特定的资源，如info.plist。除了应用程序委托，此目标不包含任何源
Koober_iOS:这个Cocoa Touch框架包含了所有特定于Koober iOS应用的UI代码，比如视图控制器和视图.
KooberUIKit:这个Cocoa Touch框架包含了所有特定于Koober iOS应用的UI代码，比如视图控制器和视图.
KooberKit:最后一个Cocoa Touch框架包含了不依赖于UIKit的代码。因此，这个框架可以在任何苹果平台上使用.

呈现MainViewController
在Xcode的项目导航器中，打开Koober/AppDelegate.swift，在应用程序的第一行(didFinishLaunchingWithOptions:)， MainViewController被injectionContainer实例化。
injectionContainer是一个工厂，它创建带有依赖项的对象实例。在这种情况下，injectionContainer允许应用程序委托创建一个新的MainViewController实例，而不需要知道MainViewController需要哪些其他对象被实例化。
在AppDelegate.swift第46行，MainViewController被设置为窗口的根视图控制器。这就是MainViewController如何到屏幕的。

显示启动屏幕
接下来,打开Koober_iOS / iOSApp / MainViewController.swift。你现在在Koober_iOS框架目标中，所有视图控制器代码都在这里。在第135行，在viewDidLoad期间，MainViewController通过observeViewModel方法订阅了一个MainViewModel
打开KooberKit / UILayer / MainViewModel.swift。您现在处于KooberKit框架目标中，在第36行，视图模型的viewSubject被初始化为。launching MainView enum case，由于初始的.launching值，当MainViewController在onViewDidLoad上订阅这个视图模型时，视图模型将向MainViewController发出。launching值
回到Koober_iOS / iOSApp / MainViewController.swift
每当发出一个新值时，视图模型的订阅将调用第69行上的present(view:)方法，因为发出的第一个值是.launching，所以presentLaunching方法在present(view:)内部被调用。在MainViewController加载之后。第94行上的presentLaunching方法将LaunchViewController作为一个子控制器添加到MainViewController，显示启动页面。

从启动到落地
到Koober_iOS/iOSApp/LaunchViewController.swift，在第48行，在loadView期间，LaunchViewController的根视图被创建
LaunchViewModel。
通过打开Koober_iOS/iOSApp/LaunchRootView.swift进入根视图。在初始化期间，在第45行，launch视图要求视图模型尝试加载用户会话，以查看用户是否已登录
打开LaunchViewModel的源代码，地址在KooberKit/UILayer/ LaunchViewModel.swift。
您可以在第58行找到loadUserSession方法。一旦这个方法完成对用户会话的查询，就会调用goToNextScreen(userSession:)
当你第一次运行Koober时，不是已登录的用户，所以goToNextScreen(userSession:)方法将被nil调用，当goToNextScreen(userSession:)确定一个用户没有登录，在第84和85行，notSignedInResponder的notSignedIn方法被调用。
接下来,打开KooberKit / UILayer / MainViewModel.swift。注意，这个视图模型符合NotSignedInResponder协议
一旦LaunchViewModel确定用户没有登录，LaunchViewModel就会通过NotSignedInResponder协议调用MainViewModel的notSignedIn方法。换句话说，MainViewModel是LaunchViewModel的nottsignedinresponder。你可以在第5章中阅读更多关于MVVM的设置。
在第42行，notSignedIn里面，注意MainViewModel是如何向viewSubject发出一个新的视图枚举case值。onboarding。这是告诉MainViewController从它的当前呈现过渡到呈现OnboardingViewController。转换发生在MainViewController的presentOnboarding方法中。

显示欢迎页面
现在OnboardingViewController在屏幕上，那么WelcomeViewController是如何呈现的呢?
打开Koober_iOS/iOSApp/Onboarding/OnboardingViewController.swift，OnboardingViewController的加载方式与MainViewController通过视图模型订阅的加载方式相同。在第62行，在viewDidLoad期间，OnboardingViewController订阅了OnboardingViewModel。
在OnboardingViewController中有一些额外的复杂性，这你不需要担心。复杂性的存在是因为OnboardingViewController是一个UINavigationController，你可以在第五章读到更多。主要的要点是OnboardingViewController加载后，presentWelcome在第86行被调用。这就是欢迎页面的呈现方式。
好吧!既然您已经熟悉了Koober的源代码，那么就可以轻松地阅读本章其余部分中的示例代码了。

本章要点
Koober，一个kangaroo叫车应用程序，是本书使用的示例应用程序。
Koober融合了现实应用中的许多复杂性，比如身份验证和导航。
在每个体系结构章节中，都有对Koober的完整重新实现。
Koober Xcode项目包括四个目标:Koober、Koober_iOS、KooberUIKit和KooberKit。
MainViewController,LaunchViewControllerandOnboardingViewController协调以启动Koober。

第四章 对象和依赖

准备深入研究面向对象编程。这样很好，因为本章讲的都是对象、它们的依赖关系以及如何将对象提供给其他对象。您将学习强大又实用的技术，使您能够更多地控制如何进行单元测试、UI测试和设计面向对象的系统。设计如何将对象分解为更小的对象，以及如何将它们连接在一起，是一项基本的体系架构技术。您需要理解这种技术，以便浏览后面章节附带的示例代码。
在本章中，您将首先了解管理对象依赖关系的好处。接着您将快速了解常见的依赖模式。最后，本章剩下的部分将深入研究一种常见的依赖模式——依赖注入。在深入研究理论之前，您将了解对象依赖关系管理技术寻求实现的目标，这样您就可以理解您可以期望从本章介绍的实践中得到什么。

建立目标
当你将本章的依赖项技术付诸实践时，你将会get到以下特性：
可维护性：轻松更改代码库而不引入缺陷的能力，也就是说，重新实现代码库的一部分而不负面影响代码库的其余部分的能力。
可测试性：确定性的单元和UI测试，例如，不依赖于你不能控制的东西的测试，比如网络。
可置换性：在编译时和运行时替换依赖项实现的能力。这种质量对于A/B测试、使用特性标志来限制特性、在测试期间用假实现替换有有bug的实现、在开发期间临时交换对象的诊断版本等等都很有用。
延迟性: 能够延迟重大决策，比如选择数据库技术。
并行工作流: 能够让多个开发人员在同一时间独立地处理同一特性，而不会相互冲突
开发期间调试可控: 代码,开发人员可以快速迭代控制构建和运行行为,例如,切换从一个keychain-based凭据库假内存凭据库,这样你不需要登录,登录屏幕上工作时一遍又一遍。
可重用性：从组件中构建一个代码库，可以在多个功能和多个应用中轻松重用。
请注意，本章中的一些技术只能实现其中的部分目标。然而，下面的高级技术可以实现所有这些目标，是不是很兴奋。这个列表在本章中被引用，以确定哪些技术可以满足这些目标。
现在你已经有了这些目标，是时候来深入理论了。

术语学习
在没有达成一致的行话的情况下，很难解释如何设计对象及其依赖项。开发人员还没有采用标准的术语集，因此为本书创建了以下定义。在您的团队请放心使用这些术语，在iOS开发者社区中使用这些术语时，已经是司空见惯。
通常，当应用程序开发者使用依赖术语时，他们指的是库与库之间的依赖。然而，在本章中，依赖关系是另一个对象为了完成某些工作而依赖的另一个对象。




依赖关系还可以依赖于其他对象。这些其他对象称为传递依赖项。



正在构造的对象是依赖于依赖项的对象




一个对象被构建的原因是为了被另一个对象——消费使用



总之，您有一个消费者，它需要构建中的对象，该对象依赖于依赖于传递依赖的依赖项，等等。
这些对象之间的关系构成了一个对象图。


在阅读以下部分的依赖模式时，您将看到Outside和Inside之间的术语。Outside指的是存在于正在构造的对象之外的代码。Inside指存在于正在构造的对象内部的代码。正如您将看到的，这种区别在架构上非常重要。
这是您在深入对象依赖关系过程中需要了解的术语。回顾何时以及如何创建依赖项将帮助您首先理解为什么存在依赖项。

创建依赖关系
依赖性最初是如何实现的?来看一些常见的场景。

重构代码臃肿类
你肯定见过他们——类里面的代码又臭又长。良好的面向对象设计鼓励类的大小和职责尽可能少。当您将这些最佳实践应用于大型类时，可以将大型类分解为一群较小的类。原来的大规模类的实例现在依赖于新的较小类的实例（单一职责）。

删除重复的代码
一位伟人曾经说过，一段相同的代码如果存在两份，那说明你不是一个合格的程序员.
软件体系架构的主要目标之一是删除尽可能多的重复代码。假设你有几个你分析的视图控制器。你会发现所有这些视图控制器都有相同的网络请求代码。将网络请求代码提取到一个单独的类中。视图控制器现在依赖于新的网络类。

控制副作用
大多数时候，这些较小的类会产生在开发和测试期间无法控制的副作用。这就是本章的内容，如何控制副作用。
如何进行重构直接影响到您可以实现多少期望目标。有三个基本的考虑因素可以帮助你实现目标。

基本注意事项
当您设计相互依赖的对象时，您必须决定正在构造的对象将如何访问其依赖项。您还需要决定是否希望替换依赖项的实现，如果是的话，如何使依赖项的实现可替换。

从内部:
全局属性：正在构造的对象可以简单地访问任何可见的全局属性。
实例化：如果一个依赖是短暂的，也就是说，这个依赖不需要比正在构造的对象存在的时间长，那么正在构造的对象就可以实例化这个依赖。
从外部:
初始化参数：可以将依赖项作为初始化器参数提供给正在构造的对象。
可变存储属性：通过在正在构造的对象上设置可见的可变存储属性，可以向已经创建的正在构造的对象提供依赖项。
方法：依赖关系可以通过构建对象的可见方法提供给正在构建的对象。

确定可置换性
并非所有依赖项都需要具有可替换的实现。例如，您可能不需要替换没有副作用的依赖项的实现，即它只包含纯业务逻辑。然而，如果依赖项向磁盘写入某些内容，进行网络调用，发送分析事件，将用户导航到另一个屏幕，等等，那么您可能希望在开发或测试期间替换依赖项的实现。

设计可置换性
如果你确实需要替换依赖的实现，那么你需要决定是需要在编译时替换实现，还是在运行时替换实现，或者两者都要替换。举例来说，当你需要为不同的用户提供不同的a /B测试体验时，你可能需要运行时可替换性。另一方面，对于测试，开发人员通常依赖于编译时可替换性。
你有了目标——接下来呢?您可能想知道为什么在一本架构书中有这么多关于测试的讨论。请开启旅程的下一站。

为什么是这个架构
虽然这些实践不一定是应用在架构上的，但实践本身要求您做出重要的结构决策。这就是为什么这些内容会出现在一本架构书里。
理论上，您可以在不使用本章中的技术的情况下设计出一个好的架构。但是，如果您正在使用行业最佳实践(比如单元测试)编写软件，那么您肯定需要了解这些技术，另一方面，这些技术并不是灵丹妙药。在使用这些技术时，也可能会设计出糟糕的体系架构。为了设计优秀的软件，你必须掌握许多难题，本章只是其中之一。
现在，您已经准备好学习如何控制对象的依赖项。有几种模式可以用来设计对象及其依赖项。本章主要讨论其中的一种模式，但是有必要先蜻蜓点水一下所有不同的模式。

依赖模式
依赖注入和服务定位器是软件工程中最常用的模式。

依赖注入：这是您将在本章中要重点学习的模式。模式的基本思想是提供正在构造的对象之外的所有依赖项。稍后再详细介绍。
服务定位器:Service Locator是一个可以创建和持有依赖项的对象.您可以为正在构造的对象提供一个服务定位器。当构建中的对象需要依赖时，构建中的对象可以简单地请求服务定位器来创建或提供依赖。这种模式比依赖注入更容易使用，但在利用自动化测试时需要做更多的工作。许多开发人员使用此模式成功地实现本章中概述的目标。

以下是Swift社区创建的其他模式:
环境：环境是一个可变结构体，它提供了正在构造的对象所需的所有依赖项。这个模式与Service Locator非常相似;唯一的区别是环境是在构建中的对象内部访问的，而服务定位器是提供给构建中的对象的。这是管理对象依赖关系的一种简洁的轻量级方法。欲了解更多信息，请查看由Brandon Williams and Stephen Celis制作的《Point Free Swift video series》系列视频。
协议扩展：该模式使用Swift的协议扩展，允许正在构建的对象访问其依赖项。要了解更多关于这个模式的信息，请参阅Daniel Hall的文章《A Swift-y Approach to Dependency Injection.》。
现在，舞台已经搭好了，是不是跃跃欲试。你已经得到了你需要的一切。是时候深入了解依赖注入的世界了。

依赖注入
依赖注入的主要目标是从正在构造的对象的外部向正在构造的对象提供依赖，而不是从正在构造的对象内部查询依赖。依赖被“注入”到正在构造的对象中。当开发者听到“依赖注入”时，他们通常想到的是依赖注入框架。然而，依赖注入首先是一个模式，你可以遵循或不遵循框架。学习依赖注入的最好方法是不使用框架。这就是为什么本书没有使用依赖注入框架的原因。
从这里，你可以了解依赖注入背后的历史，或者你可以跳过，直接进入细节。

追根溯源-依赖注入的历史
依赖注入(DI)并不是一个新概念。问任何一个Android开发者他们是否熟悉依赖注入，他们很可能会告诉你依赖注入对于构建良好架构的应用程序是必不可少的。在构建Java后端应用程序时，依赖注入也被大量使用。因此，Java开发人员在转向Android时利用这种设计模式也就不足为奇了。
在AngularJS等一些流行的框架中，DI被紧密地内置在核心中。AngularJS的官方文档中有一整节都是关于这个主题的。文档的作者强调DI“在Angular中无处不在”。
DI背后的面向对象理论已经存在一段时间了。DI基于依赖性反转原理，也称为控制反转。根据Martin Fowler的说法，控制反转最早是在1988年Johnson和Foote的一篇题为《Designing Reusable Classes》的论文中提出的。Robert Martin在1994年发表的论文《Object Oriented Design Quality Metrics: An Analysis of Dependencies》中推广了这一概念。如果你想深入挖掘面向对象设计的根源，这些论文非常值得一读。
“依赖注入”一词是由Fowler在2004年1月14日发表的一篇题为《Inversion of Control Containers and the Dependency Injection Pattern》的文章中提出的。敏捷开发和测试驱动开发的日益流行促使开发人员寻找容易测试面向对象代码的方法。因此，为了满足可测试性需求，开发人员发明了控制反转，更具体地说，是DI。正如你将看到的，使用依赖注入是构建可测试和可维护的iOS应用的关键。

类型注入
     有三种注入方式：
初始化器：当实例化正在构造的对象时，使用者向正在构造的对象的初始化器提供依赖。要启用此功能，需要将依赖项添加到正在构造的对象的初始化器参数列表中。这是最好的注入类型，因为正在构造的对象可以将依赖项存储在一个不可变的存储属性中。正在构造的对象不需要处理依赖项为nil的情况，也不需要处理依赖项更改的情况。初始化器注入并不是唯一的注入方法，来看下一个注入类型--属性注入。
属性注入：在实例化正在构造的对象之后，使用者通过在正在构造的对象上设置一个存储属性来为正在构造的对象提供一个依赖。如果没有属性注入依赖项的默认实现，则需要将属性类型设置为Optional。这种注入类型通常在接口构建器支持的视图控制器中使用，因为你无法控制UIKit使用哪个初始化器来创建接口构建器支持的视图控制器。
方法注入：在调用正在构造的对象的方法时，使用者向正在构造的对象提供依赖项。方法注入很少使用;然而，这是你的另一个选择。如果依赖项只在单个方法中使用，那么可以使用方法注入来提供依赖项。这样，正在构造的对象就不需要持有依赖项。记住，对象的状态越少越好。对象的生存期越短越好。

一个很好的经验法则是:当正在构造的对象需要依赖才能正常工作时，使用初始化器注入。如果正在构造的对象可以在没有依赖项的情况下运行，则可以使用任何类型的注入，当然推崇初始化器注入。

循环依赖
有时，两个对象之间的关系非常密切，以至于它们需要相互依赖。为了使这种情况在使用依赖注入时正常工作，你必须在循环依赖的两个对象之一中使用属性或方法注入。这是因为你不能同时初始化两个对象;你必须先创建一个，然后通过初始化器注入用第一个对象创建第二个对象，然后用第二个对象在第一个对象上设置一个属性。另外，要记住通过使一个引用为弱引用或无主引用来避免循环引用。

依赖实现
使用注入还不足以获得所有的可测试性和灵活性优势。现在目标之一是能够在测试期间控制依赖项的行为。
假设您有一个依赖项类，用于存储和从数据库中检索数据。将这个数据库对象，也就是依赖，注入到视图控制器中并不能让你控制数据库对象在测试期间的行为。因为视图控制器依赖于数据库依赖的特定实现，在运行时不能被替代。为了控制这个依赖，视图控制器应该能够接受数据库对象的不同实现，这样你控制的假实现可以在测试期间注入。
因此，单独注射不具有可替代性。要实现可替换性，需要为依赖项定义协议，这样使用者就可以注入符合依赖项协议的不同类。在设计正在构造的对象时，使用协议类型作为依赖关系。
回想一下，你可以让依赖项实现在编译时、运行时或两者都是可替换的。每个依赖都在某个地方实例化。为了替换依赖的实现，你用if- else语句来包装依赖的实例化。在一种情况下，你可以实例化一个假类型用于测试，而在另一种情况下，你可以实例化一个生产类型用于运行应用程序。编写这个if-else语句对于编译时替换和运行时替换是不同的。

编译时替换
要在Swift中有条件地编译代码，你需要在Xcode的活动编译条件构建设置中添加编译条件标识符。一旦将自定义标识符添加到活动编译条件的构建设置中，就可以使用#if和#elseif编译指令中的标识符。
您可以使用条件编译来更改特定构建配置所需的依赖项实现。例如，如果您想在测试期间使用一个假的远程API实现:
创建Test构建配置 
将目标方案的Test构建配置更改为Test构建上一步中创建的配置
向目标的活动编译条件构建设置添加TEST标识符，用于测试构建配置。
找到消费者创建真正的远程API实例的代码行。
编写一个#if TEST编译指令，并在if语句下实例化一个假的远程API。
编写一个#else编译指令，并在else下实例化一个真正的远程API。
在下一行写一个#endif编译指令来关闭条件编译块。
当你在Xcode中运行Test动作来运行单元和UI测试时，Swift编译器会编译实例化一个假的远程API的代码。当你运行任何其他构建操作时，比如run, Swift编译器会编译实例化一个真正的远程API的代码。酷毙了，跟那些试图进行真实网络测试说再见吧。

运行时替换
有时，您希望在运行时替换依赖项的实现。例如，如果你想为使用Testflight的beta测试者运行不同的逻辑，你就需要使用运行时替换，因为Testflight使用的构建与通过App Store分发给最终用户的构建完全相同。因此，对于这种情况，您不能使用编译时替换。Testflight用例只是一个例子。
要在运行时替换一个实现，需要围绕依赖项实例化编写一个if语句。您需要决定从哪里获得可以在if语句中进行比较的值。例如，你可以使用远程功能标志服务，或者你可以关闭本地值，比如应用程序的版本号。
另一个巧妙的技巧是在运行时使用启动参数替换依赖项。这在你用Xcode开发应用时很有用。这很简洁，因为你不需要重新编译应用程序来更改依赖项实现。只需从UserDefaults获取启动参数，然后用检查启动参数值的if语句包装依赖项实例化。您可以在开发期间甚至在持续集成测试期间使用这个技巧。
好的，你已经掌握了基础知识。有几种将依赖注入付诸实践的方法。您将开始学习最基本的方法，并逐渐转向更困难的、实际应用的方法。这些是你将在本章学到的依赖注入方法。
按需方式法：在这种方法中，您可以在需要时以分散的方式创建依赖关系图。这种方法很简单，但不太实用。您可以使用这种方法来巩固您对基础知识的理解，并感受一些由更高级的方法解决的问题。
工厂方法：在这里，您开始集中初始化逻辑。这种方法也相当简单，旨在帮助您学习基础知识。
单容器法：这种方法将所有初始化逻辑打包到一个容器中。由于涉及到声明，它比前两种方法更难以付诸实践。
容器层次结构法：集中所有初始化逻辑的一个问题是，你最终会得到一个庞大的类。您可以将单个容器分解为容器层次结构。这就是这个方法的意义所在。

按需方式法
这种方法设计用于学习DI和在非常简单的情况下使用DI。正如您将看到的，您可能希望在现实生活中使用更高级的方法。在按需方法中，每当消费者需要一个正在构造的新对象时，消费者在实例化正在构造的对象时创建或找到正在构造的对象所需的依赖项。换句话说，消费者负责收集所有的依赖项，并负责通过初始化器、存储属性或方法将这些依赖项提供给正在构造的对象。
初始化短暂的依赖关系
如果依赖项的寿命不需要比正在构造的对象长，因此可以由正在构造的对象拥有，那么使用者可以简单地初始化依赖项，并将这些依赖项提供给正在构造的对象。这些依赖项是临时性的，因为它们是与正在构造的对象一起创建和销毁的。
在这种情况下，因为使用者正在初始化所有的依赖项，所以使用者需要知道在初始化依赖项时使用哪个具体的实现。只要正在构造的对象为其依赖项使用协议类型，正在构造的对象就不会知道使用者用来创建依赖项的具体实现，而这正是您想要的。
长存的依赖关系
如果依赖关系需要比正在构造的对象存活的时间长，那么使用者需要找到对该依赖关系的引用。引用可能由使用者持有，因此使用者已经可以访问该依赖项。或者消费者的父对象可能持有引用。
用依赖实现
这就解决了提供依赖项的问题。如何使用这种方法替换依赖项的实现?找到所有实例化依赖的位置，并用编译条件或运行时条件语句包装实例化。

这些是按需方式的机制，它到底有设么利弊呢
按需方式的优点：
这种方法比较容易解释，也比较容易理解。
您的代码是可测试的，因为您可以用确定性的伪实现代替不确定性的副作用依赖项。
你可以推迟决定。例如，您可以在决定数据库技术时使用内存中的数据存储实现。从内存中实现更改为数据库实现很容易，因为您可以找到所有内存中实例化，并将它们替换为数据库实例化。这可能有点乏味，所以这也是一个可以在更高级的方法中解决的缺点。
您的团队可以同时处理相同的特性，因为一个开发人员可以在另一个开发人员构建依赖项的同时构建正在构建中的对象。构建正在构建的对象的开发人员可以使用依赖项的假实现，而其他开发人员构建依赖项的真实实现。

按需方式的缺点:
依赖实例化是分散的。相同的初始化逻辑可能被重复多次。
消费者需要知道如何为正在构建的对象构建整个依赖关系图。依赖项也可以有其他依赖项等等。使用者可能必须实例化很多依赖项。这并不理想，因为使用同一个正在构造的对象类的多个消费者将不得不复制依赖图实例化逻辑。

这些缺点可以通过采用工厂方法来解决。接下来您将学习这种方法。

工厂方法
按需实例化依赖是一种分散的方法，它的可伸缩性不好。这是因为，随着依赖关系图变得越来越大、越来越复杂，最终会编写大量重复的依赖关系实例化逻辑。工厂方法主要是集中依赖实例化。
这种方法适用于临时依赖，也就是说，可以在构建对象的同时实例化的依赖。这种方法不能管理长期存在的依赖项，比如单例。
在即将到来的容器方法一节中，您将学习如何管理长期存在的依赖项。
要采用工厂方法，您需要创建一个工厂类。工厂类是什么样子的?

工厂类
工厂类由一堆工厂方法组成。有些方法创建依赖关系，有些方法创建正在构造的对象。另外，工厂类没有状态，也就是说，这个类不应该有任何存储的属性。
创建工厂类的一个目标是使消费者能够创建正在构造的对象，而不必知道如何构建实例化和正在构造的对象所需的依赖关系图。这使得代码的任何部分都可以非常容易地获得所需的任何对象，无论该对象被分解成多少个较小的对象。
接下来，您将学习如何设计组成工厂类的不同类型的工厂方法。

依赖工厂方法
依赖工厂方法的职责是知道如何创建一个新的依赖实例。
创建和获取可传递的依赖项
由于依赖本身可以有自己的依赖，这些工厂方法需要在实例化依赖之前获得可传递的依赖。传递依赖性可能是短暂的，也可能是长期的。
要创建临时的过渡依赖，依赖工厂方法可以简单地调用工厂类中包含的另一个依赖工厂。
要获取对一个长期存在的传递依赖的引用，依赖工厂方法应该包含一个传递依赖的参数。通过添加参数，可以向依赖工厂方法提供长期存在的传递依赖。

解决协议的依赖关系
依赖工厂方法通常有一个协议返回类型来支持可替换性。当这是真的，依赖工厂方法封装协议和具体类型之间的映射。这通常称为解析，因为依赖项工厂方法解析要为特定的协议依赖项创建哪个实现。换句话说，这些方法知道要使用哪个具体的初始化式。
举例来说，假设您有一个UserProfileDataStore协议。假设这个协议是一个依赖项。工厂类封装了知道使用DatabaseUserProfileDataStore的逻辑，用于需要UserProfileDataStore的在建对象。您可以将此逻辑放入工厂类中的单个工厂方法中。
这集中了依赖关系的解析，这样在你的代码库中只有一个地方知道如何解析UserProfileDataStore依赖关系。这非常棒，因为你可以通过改变一行代码来改变整个应用程序使用的数据存储类型。

Object-under-construction工厂方法
构建中的对象工厂方法的职责是创建实例化一个构建中的对象所需的依赖关系图。正在构建的对象工厂方法看起来就像依赖工厂方法一样。唯一的区别是正在构建的对象工厂方法从工厂类的外部调用，而依赖工厂方法在工厂类内部调用。

获取运行时的值
有时，正在构造的对象甚至依赖项需要只能在运行时确定的值。例如，REST客户机可能需要用户ID才能正常工作。这些运行时值通常称为运行时工厂参数。顾名思义，处理这种情况的方法是为每个运行时值添加一个参数到正在构造的对象或依赖项的工厂方法中。在运行时，工厂方法调用者将需要提供所需的值作为参数。

用依赖实现
要在工厂类中启用替换，请使用与按需方法相同的技术，即使用条件语句包装依赖关系解析。在工厂方法中管理替换要容易得多，因为所有解决方案都集中在工厂类中的工厂方法中。这意味着你不必在每个消费者中重复条件语句;对于每个依赖项解析，只编写一次条件语句。这是不是很美。

注入工厂
如果正在构造的对象需要创建依赖项的多个实例，该怎么办?如果正在构建的对象是一个视图控制器，它需要在用户每次按下按钮或在文本字段中输入字符时创建一个依赖项，该怎么办?
工厂方法返回依赖的单个实例——所以，我们有一个问题。关键在于找到一种方法，使正在构造的对象能够在需要创建新的依赖项实例时多次调用工厂方法。
您的第一直觉可能是简单地在正在构造的对象中创建工厂类的实例。
然后，正在构建的对象将可以访问每一个单独的工厂方法。虽然这是一种非常简单的方法，但问题是正在构建的对象变得更难进行单元测试。这是因为所有依赖项不再从外部注入。使用这种方法，您需要使用工厂类，以便将真实的实现替换为虚假的实现。
其目标是能够在不需要工厂类的情况下对正在构建的对象进行单元测试。因此，让正在构造的对象能够从外部创建依赖项的多个实例是很重要的。
您可以使用Swift的两个特性之一从外部将这种能力赋予正在构建中的对象:闭包或协议。

使用闭包

一种是向正在构造的对象添加一个工厂闭包存储属性。步骤如下：
使用签名在正在构造的对象中声明一个存储属性，例如:let makeUseCase: () -> UseCase。
向具有相同闭包类型的正在构造的对象添加一个初始化式参数。
转到工厂类，找到创建正在构造的对象的工厂方法。
在构建中的对象工厂方法中，使用初始化器注入来注入一个创建新依赖项的闭包。为此，在正在构造的对象的初始化器调用中打开一个闭包。在闭包内部，调用有问题的依赖项的依赖工厂方法，并返回新实例。闭包捕获了工厂类实例，因此正在构造的对象实际上会在不知情的情况下保留工厂对象。
现在，无论何时，通过调用工厂闭包，正在构造的对象都可以轻松地创建依赖项的新实例。
 这很酷，因为正在构造的对象可以创建尽可能多的实例，而不需要知道在工厂闭包中创建的依赖背后的所有传递依赖。这意味着您可以更改整个依赖结构，而不必更改正在构造的对象中的任何一行代码。
这是一种选择;另一种选择是声明一个工厂协议。

使用协议
另一种方法是声明工厂协议，以便正在构造的对象可以将依赖项的创建委托给工厂类。步骤如下：
声明一个新工厂协议，该协议包含用于构建中的对象需要创建的依赖项的单个方法。
工厂类已经符合这个协议，因为协议中的依赖工厂方法应该匹配工厂类中实现的工厂方法。只需在工厂类中声明一致性。
向正在构造的对象添加工厂协议类型的存储属性和初始化器参数。这允许你将工厂对象注入到正在构建的对象中;然而，正在构造的对象只会看到协议中定义的单个工厂方法。正在构造的对象并不知道它被注入了工厂对象，因为协议蒙蔽了正在构造的对象的双眼。
进入工厂类中正在构造的对象的工厂方法，并更新初始化行以注入self。Self是符合您声明的新工厂协议的工厂对象。
正在构造的对象现在可以随时创建新的依赖项实例，但不能访问工厂类中的所有工厂。使用这种方法可以获得与闭包方法相同的好处。这个决定归结为风格偏好。
这就是注入工厂的全部内容。现在我们来快速了解一下何时以及如何创建工厂类的实例。

创建工厂对象
由于工厂类是无状态的，所以您可以在任何时候创建工厂类的实例。您可能会想，为什么不把所有的工厂方法都变成静态的，这样您甚至不必创建实例。你当然可以这么做;然而，当您将工厂类升级为容器类时，您将最终使大多数工厂成员方法。
在了解这种工厂方法的优缺点之后，您将在接下来了解这一点。

工厂方式的优点
临时依赖项是在中心位置创建的。这为您提供了很大的能力，可以通过更改几行代码来切换整个子系统。
在功能UI测试期间替换大量的依赖项要容易得多，因为所有的依赖项都在一个类中初始化。开发人员通常希望在UI测试期间伪造整个网络和持久性堆栈，因为开发人员希望确定性测试，这样他们的构建就不会经常因误报而中断。
消费者更能适应变化，因为他们不再需要知道如何构建依赖关系图。这样所有消费者的责任就少了一个。这有助于您的团队并行工作，因为代码是更松散的耦合。
代码通常更容易阅读，因为所有的初始化样板都从那些做有趣工作的类中移出。
工厂方法的缺点
在大型应用程序中，单个工厂类可以变得非常大。您可以将大型工厂类分解为多个类。
这种方法只适用于短暂的对象。长期存在的对象需要保存在某个地方。理想情况下，所有依赖项都应该集中管理，而不考虑寿命。在下一节中，您将学习如何做到这一点。
实际上，工厂类是不够的。您很可能需要将工厂类转换为容器类。
这里的工厂部分是为了帮助您采取一些小步骤，因为关于DI还有很多东西需要学习。
当重构代码库以使用DI时，可以采用这种工厂方法来感受模式。在下一节中您将看到，您可以轻松地更新代码，从这种工厂方法转向容器方法。

Single-container方法
容器类似于工厂类，可以持有长期存在的依赖项。容器是工厂类的有状态版本。
有哪些长期依赖关系的例子?数据存储就是一个很好的例子。数据存储是呈现屏幕所需的数据的容器。由于该数据可能会发生变化，因此需要该数据的单个副本。因此，您不希望在每次对象需要数据存储时都创建一个新的数据存储实例。您可能希望一个实例在应用程序的进程中一直存在，也就是说，您需要一个单例。为了让一个数据存储实例处于活动状态，你需要一个对象来持有这个单例，这样ARC就不会去分配这个数据存储
继续阅读，了解如何设计容器类。

容器类
容器类看起来就像一个工厂类，只不过它具有保存长期依赖关系的存储属性。您可以在容器的初始化过程中初始化常量存储属性，或者如果属性使用大量资源，则可以延迟创建属性。然而，惰性属性必须是变量，所以默认情况下常量属性更好
将长期存在的依赖项与工厂放在一起会，将会改变工厂访问这些长期存在的依赖项的方式。接下来，您将进一步探讨这个问题。

依赖工厂方法
回想一下，依赖工厂方法的职责是如何创建一个新的依赖实例。容器中的依赖工厂方法和工厂类中的工厂方法一样，会创建临时的过渡依赖，例如，通过调用另一个依赖工厂。
但是，依赖工厂方法在容器中如何获得长期存在的依赖关系，与在工厂类中不同。

要获取对一个长期的传递依赖项的引用，依赖项工厂方法只需从存储的属性中获取该依赖项。这真的很好，因为这消除了向工厂方法添加参数的需要。

所有工厂方法都可以在没有任何输入的情况下被调用。这些方法可以没有参数的事实是非常强大的。使用复杂初始化器(如init(remoteAPI: UserRemoteAPI, dataStore: UserDataStore))获取依赖，并将其缩减为工厂方法，如makeProfileViewModel()。

除了运行时值参数外，以上都是正确的。由于运行时值是在容器外部提供的，而且运行时值不是长期存在的依赖项，因此容器中的工厂方法仍然更容易调用。稍后您将看到，在注入工厂时，这将派上用场。

(正在构建的)Object-under-construction工厂方法
创建正在构建的对象的工厂方法也可以使用存储的属性将长期存在的依赖注入到正在构建的对象中。
就像上面提到的依赖工厂方法一样，这些工厂方法也不需要为长期存在的依赖提供参数。这对消费者来说是一个巨大的好处，因为消费者不必为了创建正在构建的对象而管理任何东西。它们只是调用空参数工厂方法或提供运行时值。
消费者现在可以创建正在构建的对象，而不必了解这些对象背后的依赖关系图。这为您的代码提供了灵活性，因为开发人员可以更改依赖关系图，而不会影响围绕消费者构建代码的开发人员。
它负责将容器的存储属性链接到工厂方法实现。接下来，您将快速了解如何替换存储属性所持有的长期生存依赖项的实现。

替换长期存在的依赖项实现
您可以通过用条件语句包装长期依赖项的初始化行来替换它们的实现。这是可能的，只要长期存在的存储属性使用协议类型。你也可以使用工厂的方法;不同之处在于，替换现在是集中的。

是不是很容易。此时，您可能想知道何时以及如何创建容器。

创建并保存容器
与工厂不同，您应该只创建一个容器实例。这是因为容器持有必须重用的依赖项。这意味着当你的应用程序在内存中时，你需要找到一个永远不会被销毁的对象。你通常会在应用程序启动过程中创建一个容器，通常会将容器存储在一个应用程序委托代理中。你将在本章的第二部分阅读更多关于如何做到这一点的内容，这将演示如何将这一理论应用于iOS应用程序。

从学习如何建造一个工厂类到学习如何建造一个集装箱并不是一个巨大的飞跃。但是，当需要将单个容器分解为容器层次结构时，容器背后的理论就变得有趣了。在了解了单容器方法的优缺点之后，您将在接下来了解这一点

单容器方法的优点
容器可以管理应用程序的整个依赖关系图。这就不需要其他代码知道如何构建对象图。
容器管理单例;因此，在全局空间中不会有单例引用浮动。单例现在可以由容器集中管理。
您可以更改对象的依赖关系图，而不必更改容器类外的代码。

单容器方法的缺点
将应用程序所需的所有长期依赖项和所有工厂方法放到一个容器类中，可能会产生一个大型容器类。这是使用DI时最常见的问题。好消息是你可以把这个巨大的容器分解成更小的容器。您将在下一节中了解到这一点。

容器层次结构的设计
到目前为止，您已经了解了不需要重用的临时对象，以及在应用程序的整个生命周期中保持存活的长期对象。到目前为止，您学到的技术已经足以使用DI构建一个真实世界的应用程序。尽管如此，当您开始使用带有单个容器的DI代码库时，您会发现这玩意有时不好用。

使用单个容器检查问题
你首先会注意到的是一个不断增长的容器类——当你向应用程序添加更多的特性时，你需要更多的依赖项。这表现为容器中越来越多的工厂方法，以及越来越多的单例依赖项的存储属性。

您还会注意到许多可选的条件展开。大多数应用程序都有很多依赖项，它们需要了解当前登录的用户来完成诸如验证HTTP请求之类的事情。

如果所有可重用的依赖项和应用程序一样长，容器逻辑将需要处理可选情况，因为用户可以在应用程序运行时被签出。

根据到目前为止的容器设计，没有什么能阻止任何消费者向容器询问需要用户登录的依赖项。

理想情况下，用户只有在登录时才能访问这些可重用的依赖项。这只是潜入到单一依赖项容器中的可选案例处理的众多例子之一。

在本节中，您将学习如何使用高级DI技术来解决这些不良问题。

对象范围
解决这些问题的诀窍是设计对象范围。要做到这一点，请考虑应该在什么时间点创建和销毁依赖项。每个物体都有生命周期。您需要明确地设计对象何时出现何时消失。例如，用户范围内的对象在用户签入时创建，在用户签出时销毁。视图控制器范围中的对象在视图控制器加载时被创建，在视图控制器被解除分配时被销毁。
以下是你在大多数应用程序中发现的典型作用域：
应用范围:传统的单例应用属于这个范围。应用程序范围内的对象在应用程序启动时被创建，在应用程序被杀死时被销毁。在此范围内发现的典型依赖关系包括身份验证存储、分析跟踪器、日志系统等。
用户范围:用户范围对象在用户签入时创建，在用户签出时销毁。一些应用程序允许用户登录多个账户。在这种情况下，应用程序可以同时有多个活跃的用户作用域。大多数依赖项，比如远程API和数据存储，通常都在这个范围内。这个作用域通常还包含在应用程序作用域中找到的依赖项的更具体版本。例如，应用程序范围可以有一个匿名分析跟踪器，而用户范围可以有一个用户特定的分析跟踪器。作用域非常强大，因为它们有助于将一堆可变状态转换为不可变状态。由于这个原因，您可以通过设计更短的作用域来进一步使用作用域。这里有几个例子。
特性范围:特性范围中的对象在用户导航到某个特性时创建，在用户导航离开时销毁。当一个特性需要在组成该特性的许多对象之间共享数据时，特性作用域非常方便。
例如，在Koober中，提醒功能需要知道用户的当前位置。用户的当前位置被获取一次，然后不再被获取;从提醒功能的角度来看，当前位置是不可变的。

许多具有业务逻辑的不同视图控制器和对象需要利用当前的位置值来发挥作用。

想象一下必须在对象之间传递这个值。通过创建特性作用域，可以将当前位置注入到所有这些对象中。

对象不需要担心如何获取值。就该特性中的对象而言，位置值是不可变的，即使用户仍然可以请求一次新的乘坐，并且将获取一个新的当前位置。因为每当用户开始一个新的骑行时，一个全新的对象图就会用当前的静态位置值创建。
交互作用域:交互作用域中的对象在识别手势时被创建，在手势结束时被销毁。当您构建复杂的用户交互时，这很方便。这是一个非常短暂的范围的示例。
一旦设计了所需的作用域，并且确定了哪些依赖项应该存在于哪些作用域中，下一步就是将单个容器分解为容器层次结构。

容器层次结构
容器管理它所持有的依赖项的生存期。因此，每个作用域映射到一个容器。一个用户作用域应该有一个用户作用域的容器。用户范围容器是在用户登录时创建的，以此类推。这就是用户作用域中的依赖项是如何同时创建和销毁的，因为作用域容器拥有这些对象

对于您设计的每个作用域，您都创建一个容器类。当您这样做时，会发现限定作用域的容器如果要访问其他容器的工厂方法和存储属性。此时，就需要构建容器层次结构。

设计容器层次结构
构建容器层次结构有一个简单的规则:子容器可以向父容器请求依赖关系，包括父容器的父容器等等，一直到根容器。父容器不能向子容器请求依赖项。

应用范围容器始终是根容器。如果考虑到层次结构如何映射到对象生存期的长度，则该规则非常有意义。父容器的寿命长于子容器。如果允许父容器向子容器请求依赖项，则子容器可能不再存在。这就是规则的基本原理。

你准备好接受超能力了吗?

容器层次结构本身就是一个对象图;因此，您可以使用初始化器注入来为父容器提供子容器。

与所有的DI约定一样，这听起来比实际情况要复杂得多。子容器的初始化式需要父容器的参数。然后，子容器可以在存储属性中保存对父容器的引用。这使得子容器可以访问父容器中的所有工厂方法和存储属性。

例如，假设你有一个UserProfileViewModel。这个视图模型需要一个Logger来记录事件。Logger需要在应用程序活着的时候一直存在，因为无论用户是否登录，你都希望能够记录消息。因此记录器进入AppDependencyContainer。

但是，UserProfileViewModel是特定于登录用户的，因此该对象的作用域为登录用户。视图模型进入UserDependencyContainer。视图模型需要记录器，但记录器位于不同的容器中。

要解决这个问题，你需要在UserDependencyContainer的初始化器中添加一个AppDependencyContainer参数。这样，当初始化一个新的UserProfileViewModel时，子容器UserDependencyContainer可以向父容器AppDependencyContainer请求一个日志记录器

捕捉数据
将容器分解为容器层次结构可以解决第一个不便之处。那第二个不便呢——处理可选配件的那个?

除了管理依赖关系的生命周期外，容器还可以捕获数据模型值。如果数据模型值在容器的生命周期内是不可变的，这将非常有用。在容器中捕获数据是将可变值转换为不可变值的一种方法。这使得容器内的代码更具确定性，因为逻辑不必考虑捕获值的更改。

举例来说，假设你有一个名为AppContainer的应用范围容器。AppContainer有一个UserSessionDataStore，它只在用户登录时包含用户会话。假设您有一个名为UserContainer的用户范围容器。UserContainer用一个AppContainer和当前登录的用户会话对象初始化——不是数据存储，而是实际的会话。

这非常重要，而且非常简洁，因为没有用户会话，用户容器就不能存在。这就去掉了与登录用户相关的可选案例处理。

继续看下面的例子，在UserContainer内部，假设您有一个用于创建UserProfileRemoteAPI的工厂方法。远程API需要用户会话才能正常工作。这很简单——远程API工厂方法可以访问用户会话存储的属性。

记住，工厂和存储属性都在同一个UserContainer类中。必须检查整个代码库是否有登录用户的这种情况已经不存在了，是不是很爽!

容器层次结构的优点
作用域允许您设计不必是单例的依赖项
通过捕获作用域中的值，可以将可变值转换为不可变值
当将容器类划分为有作用域的容器类时，容器类会更短小精悍

容器层次结构的缺点
容器层次结构比单容器解决方案更复杂。加入您团队的开发人员可能会遇到略微陡峭的学习曲线。
即使容器被分解成限定作用域的容器，复杂的应用程序最终可能仍然会产生非常长的容器类。

至此，您已经学习了很多关于DI的知识，并且正在掌握面向对象的设计。这就是您理解示例应用程序Koober如何使用DI所需要的所有理论。在本书中，您将遇到使用不同架构构建的Koober的不同版本。DI是一种非常通用的方法，你将看到的Koober的每个版本都使用相同的DI模式，因为DI可以支持各种不同的体系结构。

你所读到的大多数理论都适用于iOS，无需任何特殊考虑。然而，当你在iOS代码库中使用DI时，你需要做出一些特定于iOS的决定。是时候从理论到实践了。

将DI理论应用于iOS应用
在本节中，您将看到您刚刚学习的理论是如何应用于Koober的，这样您就可以看到DI在真实世界的应用程序中是什么样子的。首先，您将探索在Koober中验证用户所需的所有对象和协议。然后，您将使用按需方式、工厂和单容器方法将所有这些对象放在一起。最后，您将看到在Koober中如何使用容器层次结构来定义应用程序和加载范围中的对象。

对象图和iOS应用程序
因为Cocoa Touch是一个面向对象的SDK，所以每个iOS应用在运行时都包含一个对象图。UIApplication的一个实例是一个应用程序的对象图的根。一个符合UIApplicationDelegate的对象是UIApplication的子对象。因为应用委托是iOS应用的主要入口点，应用委托是DI出现的第一个地方，所以从那里开始是有意义的。

你通常首先实例化的对象之一是根视图控制器。Koober的根视图控制器是你将要探索的第一个正在构建对象的例子。根视图控制器是你在构建iOS应用时设计的对象图的根。最终目标是学习如何使用DI容器来构造这个对象图。在本章的其余部分中，您将采取步骤实现这一最终目标。

要设置状态，下面的部分将向您介绍所需的对象图 ，在Koober中验证用户。

学习Kooberʼ的认证对象图
下面是创建KooberUserSessionRepository所需的所有协议和对象：
AuthRemoteAPI: AuthRemoteAPI协议代表Koober用户认证系统的网络层。该协议的实现负责与Koober的云服务通信，以注册现有用户和注册新用户。作为身份验证尝试成功的交换，Koober Cloud返回一个令牌，用于发出经过身份验证的HTTP请求。示例代码使用FakeAuthRemoteAPI，所以使用Koober不需要网络连接或本地服务器。AuthRemoteAPI的所有实现都不依赖于任何其他对象。
UserSessionCoding:实现UserSessionCoding协议的对象负责将UserSession对象编码为Data，并将Data解码为UserSession对象。Koober的KeychainUserSessionDataStore使用这个在keychain中存储UserSession作为数据。
UserSessionDataStore: UserSessionDataStore的实现负责为登录的用户存储用户会话。Koober包含了该协议的许多不同实现.
例如，您可以在开发期间使用FileUserSessionDataStore，以便能够通过在模拟器中删除应用程序来签出当前用户。KeychainUserSessionDataStore设计用于应用商店构建，这样Koober可以在Keychain中存储真实的用户凭据。KeychainUserSessionDataStore依赖于符合UserSessionCoding的用户会话编码器。
UserSessionRepository:这个存储库是用于管理用户会话的创建、读取、更新和删除协议。它用于在Koober启动时确定用户是否已登录，它用于登录现有用户，并用于注册新用户。KooberUserSessionRepository实现了这个协议，并且是在Koober中使用的默认实现。KooberUserSessionRepository是有状态的，一定是一个和应用一样长时间存在的长期依赖。

这是KooberUserSessionRepository的依赖图:



下面是当UserSessionDataStore被解析后KooberUserSessionRepository的依赖关系图



最后，这是KooberUserSessionRepository完全物化的依赖图的样子：



LaunchViewControllerʼ依赖图
这些是创建一个LaunchViewController所需的所有协议和对象:
NotSignedInResponder: notsigndinresponder是一种用户认证协议。Koober中的对象在确定用户未登录时调用此协议。
这可能发生在启动期间或用户退出时。实现该协议的对象负责将用户导航到OnboardingViewController。MainViewModel实现了这个协议。
SignedInResponder: SignedInResponder也是一种用户身份验证协议。当Koober中的对象确定用户已登录时，将使用此协议。
这可以发生在启动时，也可以发生在用户成功登录或注册后。MainViewModel实现了这个协议。

LaunchViewModel: 这个视图模型保存LaunchViewController的UI状态。这个对象通常是一个长期的依赖，但在Koober中，它是短暂的，因为Koober只创建一个LaunchViewController，因为应用程序在一个进程生命周期中只冷启动一次。
LaunchViewController:当Koober第一次启动时，Koober需要启动所有子系统，并需要确定用户是否已登录。当Koober启动时，LaunchViewController开始寻找一个已登录的用户并呈现一个启动画面。LaunchViewController依赖于LaunchViewModel来开始搜索一个已登录的用户。

这是LaunchViewController的依赖图:

下面是LaunchViewController完全物化的依赖关系图：

OnboardingViewControllerʼ依赖图

OnboardingViewController依赖于以下协议和对象：
OnboardingViewModel:它保存OnboardingViewController的UI状态。这对象是在用户签出时存在的长期依赖项。
GoToSignUpNavigator: GoToSignUpNavigator是一个UI导航协议。实现者负责将用户带到注册屏幕。OnboardingViewModel实现了这个协议。
GoToSignInNavigator：GoToSignInNavigator是一个UI导航协议。实现者负责将用户带到登录屏幕。OnboardingViewModel实现了这个协议。
WelcomeViewModel：这个视图模型保存了一个WelcomeViewController的UI状态。
WelcomeViewController：这个视图控制器呈现欢迎屏幕，其中用户可以进入注册界面，也可以进入登录界面。
SignInViewModel：它保存了一个SignInViewController的UI状态。
SignInViewController：用户使用这个视图控制器登录到Koober。
SignUpViewModel：这个视图模型保存了一个SignUpViewController的UI状态。
SignUpViewController：用户使用这个视图控制器创建一个新的Koober帐户。
OnboardingViewController：如果用户没有登录，Koober的MainViewController会显示一个OnboardingViewController。

OnboardingViewController是一个容器视图控制器，负责管理欢迎屏幕和登录和注册屏幕之间的导航。该控制器只有在用户未登录时才应该处于活动状态。

这是OnboardingViewController的依赖图:



下面是OnboardingViewController完全物化的依赖图：

MainViewControllerʼ依赖图
最后，这里是MainViewController依赖的协议和对象:
MainViewModel: MainViewModel保存了一个MainViewController的UI状态。这对象是有状态;因此，它需要是一个长期存在的依赖关系。
MainViewController：MainViewController是Koober的根视图控制器。MainViewController是一个管理顶级导航的容器视图控制器。
为了说明这一点，MainViewController显示和取消启动屏幕，开机屏幕和登录屏幕。MainViewController依赖于视图控制器工厂方法来创建LaunchViewControllers, OnboardingViewControllers和SignedInViewControllers。

下面是MainViewController完全物化的依赖图:

现在您已经熟悉了Koober的顶级对象图，您将看到如何使用按需方法构建这个图。

应用按需方式
MainViewController是Koober的根视图控制器类。MainViewController是本节正在构建的对象。

跟踪MainViewControllerʼ年代依赖性
为了实例化MainViewController，你首先需要实例化MainViewController的依赖项。这是MainViewController的初始化器的方法签名。Koober中真正的初始化式要复杂一些;这是一个演示按需依赖注入方法的简化版本:
 public init(viewModel: MainViewModel,
                   launchViewController: LaunchViewController)

MainViewController有两个依赖项，一个MainViewModel和一个LaunchViewController。创建一个MainViewModel很简单：
 let mainViewModel = MainViewModel()


然而，创建一个LaunchViewController更复杂，因为LaunchViewController有它自己的依赖图。这个图的对象被认为是MainViewController的过渡依赖。

这是LaunchViewController初始化器的方法签名。
public init(viewModel: LaunchViewModel)

要创建一个LaunchViewController，你需要首先使用LaunchViewModel的初始化器创建一个LaunchViewModel：
public init(userSessionRepository: UserSessionRepository,
           	  notSignedInResponder: NotSignedInResponder,

          	  signedInResponder: SignedInResponder)

LaunchViewModel有三个依赖项，UserSessionRepository, NotSignedInResponder和SignedInResponder。

正如您所看到的，将大型对象分解为单一责任对象会产生深层对象图。由于这个原因，您会发现按需方法对于具有大而深的对象图的实际应用程序不是很实用。
随需应变的方法很适合教DI，也适合在小应用中使用依赖注入。尽管如此，我们还是有必要看看如何使用按需方法来构建MainViewController的依赖图，作为学习工厂方法的踏脚石。

创建一个共享的UserSessionRepository
第一步是看看如何创建UserSessionRepository。记住，主要目标是创建一个MainViewController。跟踪MainViewController的依赖关系图，你会发现，最终，你会需要一个LaunchViewModel。你将会看到UserSessionRepository，因为LaunchViewModel需要一个UserSessionRepository。

UserSessionRepository是一个协议，所以您需要解析到一个实现。Koober使用了一个名为KooberUserSessionRepository的默认实现。KooberUserSessionRepository状态;因此，当另一个对象需要这个依赖时，不应该实例化一个新实例。您需要创建该对象一次并持有它，以便所有正在构建的对象都可以使用相同的KooberUserSessionRepository实例。

一个自由的全局常数是存放这个对象的好地方，因为它需要存在很长时间，应用程序正在运行。下面是如何设置它:

尽管KooberUserSessionRepository有一个相对简单的依赖关系图，但是要构建它的依赖关系图需要大量的代码。

如果KooberUserSessionRepository可以实例化多次，那么在使用按需方式时，每次需要一个新的KooberUserSessionRepository时，都必须复制所有这些代码。这种重复是按需方法的主要缺点，也是这种方法在现实生活中不实际的原因。

替换的UserSessionDataStore
假设你想在开发库伯的登录和注册界面时避免使用钥匙链。您希望能够使用仅用于开发的基于文件的凭据存储，以便通过在模拟器中删除应用程序来清除已登录的用户。您可以使用理论部分讨论的条件编译技术来设置编译时替换。

下面的示例演示了如何通过使用条件编译更新前面的代码示例来实现这一点：




这个示例根据USER_SESSION_DATASTORE_FILEBASED标识符切换哪些UserSessionDataStore被初始化。如果当前方案的活动编译条件构建设置包含此标识符，编译器将编译初始化FileUserSessionDataStore的代码。否则，编译初始化KeychainUserSessionDataStore的代码。

与前面一样，如果您可以创建多个UserSessionDataStore，如果您希望在您的代码库中使用相同的UserSessionDataStore实现，则必须复制条件编译。这是不方便和不受欢迎的。与工厂和容器方法一起使用时，替代方法要强大得多。

这就完成了UserSessionDataStore的创建。在下一节中，这个例子将使用这段代码来创建一个MainViewController。

创建一个MainViewController
UserSessionRepository是最终创建MainViewController所需的唯一共享实例。

现在你已经看到了如何设置一个共享实例依赖，是时候进入application(_:didFinishLaunchingWithOptions:)来看看MainViewController是如何创建和安装的。




注意GlobalUserSessionRepository共享实例是如何用来创建LaunchViewModel的。本例中的所有其他依赖项都是在应用程序(_:didFinishLaunchingWithOptions:)中创建的。在安装为根视图控制器之前，MainViewController最终被实例化了。

到目前为止，您已经看到了如何使用按需方法来构建根视图控制器的对象图。app委托并不是app需要创建新对象的唯一地方。接下来，你将访问MainViewController的实现，看看当父视图控制器需要创建子视图控制器的新实例时，按需方式是如何工作的。

按需创建OnboardingViewController
当在应用委托之外使用按需方式时，主要的挑战是访问共享实例依赖。在前面的示例中，您看到了如何将UserSessionRepository存储在一个全局常量中。在本节中，你将看到MainViewController如何使用这个共享实例来构建另一个对象图。

以这种方式使用全局引用并不理想。在本章的后面，您将看到如何使用容器而不是全局引用来存储共享实例。

下面的例子展示了MainViewController如何创建一个OnboardingViewController。在冷启动期间，如果LaunchViewController已经确定一个用户没有登录，MainViewController将实例化一个OnboardingViewController。

因为OnboardingViewController依赖于一个对象的图形MainViewController 需要创建所有OnboardingViewController的依赖项。

下面的方法来自MainViewController的实现，并展示了如何实现OnboardingViewController被创建。


上面的方法是相当不言自明的。它创建并呈现一个OnboardingViewController。顺便说一下，这是一个很长的方法!这就是按需方式的问题所在。如果你在一个复杂的应用程序中使用按需方法，你会发现像这样的长方法随处可见。这总比没有好，因为您的对象现在很容易进行单元测试。但是，正如您在理论部分看到的，有一个更好的方法。

应用工厂方法
你已经看到了如何将按需方法应用到Koober上。您看到了对象图是如何到处组装的。理解按需方法可以帮助您轻松地学习如何应用工厂方法。
在本节中，您将学习如何使用一个名为KooberObjectFactories的工厂类来创建与上一节相同的对象。

您将从查看创建UserSessionRepository所需的方法开始。然后，您将看到如何使用KooberObjectFactories创建一个共享的全局UserSessionRepository。从那里，你将通过方法来创建一个MainViewController。

你将看到如何通过注入一个工厂闭包来赋予MainViewController创建OnboardingViewControllers的能力。你将通过学习KooberObjectFactories是如何在Koober的应用程序委托中使用的，以及当MainViewController需要创建一个新的OnboardingViewController时，它是如何调用工厂闭包来结束这个例子的。

创建一个共享的UserSessionRepository
下面的代码示例演示了如何构建一个简单的工厂类，它可以创建UserSessionRepository和UserSessionRepository依赖图中的所有对象:



本例使用了GlobalUserSessionRepository声明中的所有代码，并将对象初始化分配到工厂方法中，每个依赖项对应一个工厂方法。

工厂方法的一个真正的优点是，它们可以隐藏实现替换。例如，查看上面代码中的makeUserSessionDataStore()。这个方法的调用者不知道他们可能会得到FileUserSessionDataStore或KeychainUserSessionDataStore。

这很好，因为这使您可以通过更改一个方法而不需要更改任何调用代码来更改要使用的数据存储。

现在工厂类已经设置好了，下面看看GlobalUserSessionRepository是如何声明的。


这比您在按需方法示例中看到的相同声明的代码要少得多。工厂方法将大量的样板代码从对象使用站点转移到集中的工厂类中。这可以帮助您和其他开发人员阅读代码，因为您不必推理对象图是如何组装的。如果你需要查看一个对象是如何构造的，工厂类总是Command-click 方式。
好了，这就是使用工厂方法创建全局共享UserSessionRepository的方式。接下来，你将看到如何使用这段代码创建一个MainViewController。

创建一个MainViewController
回想一下你在按需示例中看到的MainViewController初始化器

这是一个简化的初始化式;库伯的那个更复杂。在Koober中使用的初始化器需要几个工厂闭包，因为MainViewController需要能够在它被创建后创建视图控制器。这是Koober中使用的初始化器：


考虑到这增加了相当多的复杂性，您将首先浏览一个工厂示例，该示例使用了来自按需方法的相同的简单初始化器，然后您将研究使用更复杂的初始化器所需的代码。
因为MainViewController需要一个MainViewModel，你首先会看到工厂方法是如何创建一个MainViewModel的。下面的代码为KooberObjectFactories添加了一个MainViewModel工厂方法:

关于这段代码没有太多要说的;它添加了一个简单的工厂方法。接下来让我们来看下它的用途。

因为MainViewModel是有状态的，所以工厂设置应该只创建一个MainViewModel实例。由于这个原因，您需要一个全局常量，如下所示：


这个例子也非常简单。把一个共享的MainViewModel放到一个全局常量中，就可以让KooberObjectFactories访问这个共享实例。

现在KooberObjectFactories可以创建和访问一个共享的MainViewModel，是时候赋予KooberObjectFactories创建MainViewController的能力了:


现在KooberObjectFactories可以创建和访问一个共享的MainViewModel，是时候赋予KooberObjectFactories创建MainViewController的能力了:
1，注意这个工厂方法是如何有两个参数的。因为KooberObjectFactories是无状态的，并且不知道长期存在的依赖项保存在哪里，所以必须将长期存在的依赖项传递到工厂方法中。在这一行中，viewModel和userSessionRepository参数都是长期存在的。
2，这是另一个工厂方法，需要从外部传入依赖项。LaunchViewModel需要符合NotSignedInResponder和SignedInResponder的对象。你我都知道MainViewModel符合这一点，但是KooberObjectFactories并不知道，因为KooberObjectFactories并不管理长期依赖，而MainViewModel本身就是一个长期依赖。因此，KooberObjectFactories不能创建NotSignedInResponder或SignedInResponder。

在按需示例中，等价的代码在application(_:didFinishLaunchingWithOptions:)中。说到应用程序(_:didFinishLaunchingWithOptions:)，现在实例化是集中的，这个方法看起来像什么。




上面的代码获取了创建MainViewController所需的共享实例，创建了一个工厂类实例，最后使用工厂类实例创建了一个MainViewController。
不管MainViewController的依赖图有多复杂，上面的代码在大多数情况下都是一样的。

例如，如果MainViewController需要更多的5个临时依赖项，上面的代码根本不会改变。这是因为负责构建MainViewController依赖图所需的临时依赖的代码不再在application(_:didFinishLaunchingWithOptions:)中，它现在在kooberobjectfactory .e中。

另一方面，如果MainViewController需要更多的长期依赖，上面的代码将需要做一点改变，以便访问长期依赖。正如您稍后将看到的，在将工厂类升级为容器类时不会出现这种情况。

请记住，工厂类是无状态的。您可以在需要调用工厂方法时实例化该类。只要记住，在除app委托之外的任何对象中做这个会使你的对象更难进行单元测试

太棒了!现在您已经知道了如何设计一个简单的工厂类。您前面看到的那个复杂的初始化式呢?这个例子中需要添加什么代码?这个例子将从使用以下MainViewController初始化器开始。

到下面的初始化式：

如果你回想一下之前看到的Koober真正的MainViewController初始化器，你会注意到这个新版本并不完全相同。此版本缺少最后一个工厂闭包参数。这是因为遍历添加最后一个工厂关闭参数将花费很长时间。

好消息是:如果您理解了上面的版本是如何工作的，那么您就会理解它是如何工作的真正的版本也可以！

另外，这里是相应的更新后的依赖关系图：




本示例的下一部分将演示如何将工厂注入到正在构建的对象中。下面是第一部分代码:



上面的代码修改了MainViewController的工厂方法，以适应MainViewController初始化器的工厂注入版本。注意这个例子是如何添加一个名为onboardingViewControllerFactory的闭包常量的。这个工厂闭包是通过初始化注入到MainViewController的。

onboardingViewControllerFactory的主体应该创建并返回一个新的OnboardingViewController。在上面的例子中，主体是空的，因为KooberObjectFactories缺少用于创建OnboardingViewControllers的工厂方法。

下面的代码添加了这些工厂方法：




OnboardingViewController有一个相当不错的依赖图。上面的代码之前在这个例子的按需版本的MainViewController的presentOnboarding()方法中。组装OnboardingViewController对象图的复杂性现在已经超出了MainViewController。这允许MainViewController专注于成为一个优秀的视图控制器。

KooberObjectFactories现在可以创建OnboardingViewControllers了。下面的例子说明了如何在onboardingViewControllerFactory闭包中使用这个功能。



在上面的例子中，onboardingViewControllerFactory闭包简单地调用了前面的OnboardingViewController工厂方法。这个闭包捕获了传入MainViewController工厂方法的userSessionRepository和mainViewModel参数。

这些对象被用来调用OnboardingViewController的工厂方法。闭包还捕获了self，也就是KooberObjectFactories实例。

所以，以一种间接的方式，MainViewController持有一个对KooberObjectFactories的引用，这是可以的，因为KooberObjectFactories是无状态的。这样就没有机会实现挽留循环。

这就是你注入工厂的方式!为了给MainViewController创建OnboardingViewControllers的能力，有很多必要的改变。看看应用程序(_:didFinishLaunchingWithOptions:)需要改变来解释所有这些：


等一下…没错，一切都没有改变。您现在已经见证了人工智能令人敬畏的力量。另外，还记得on- boarding例子中很长的presentOnboarding()方法吗?

现在来看看这个方法:


为了创建一个新的OnboardingViewController, MainViewController只需调用空参数makeOnboardingViewController闭包属性。MainViewController不需要知道任何关于创建一个新的OnboardingViewController所需的依赖图的信息。太酷了!

你开始成为DI大师了。但是等等——还有更多。KooberObjectFactories的一个问题是，您必须为长期存在的依赖项创建全局常量。你可能不希望这些物体只是在全局空间中。为了解决这个问题，你将在下一节中看到如何将KooberObjectFactories升级为KooberAppDependencyContainer。

应用single-container 方法
为了将KooberObjectFactories转换成一个依赖容器，KooberObjectFactories需要从无状态变成有状态。您可以使用容器来持有长期存在的依赖项，例如UserSessionRepository。为了理解转换中的所有变化，你将看到KooberAppDependencyContainer是如何从头开始构建的.
业务的第一步是创建和存储共享的UserSessionRepository:


下面是每个部分的工作:
这声明了一个常量存储属性,这个属性持有在创建依赖于UserSessionRepository的在建对象时应该使用的共享UserSessionRepository实例。
注意这些工厂方法是如何在容器的初始化式中的。这些工厂方法不能是实例方法，因为在所有存储的属性初始化之前，Swift不允许初始化器调用self上的方法。在本例中，您需要这些方法来初始化存储的属性。
共享的UserSessionRepository存储属性是用内联工厂方法创建的UserSessionRepository初始化的。
上面的示例为容器提供了完全创建和存储共享UserSessionRepository的能力。接下来，你将看到如何赋予容器创建MainViewController的能力。

MainViewController需要三个大的东西来实例化:一个共享的MainViewModel，一个OnboardingViewController工厂闭包，和一个LaunchViewController。您将按以下顺序为这些依赖项添加工厂方法。
MainViewModel是第一。共享的MainViewModel是另一个需要转移到容器中的全局长依赖。下面的代码sharedMainViewModel添加到KooberAppDependencyContainer中:




下面是每个部分的工作:
这一行添加了一个常量存储属性来持有一个共享的MainViewModel。当一个正在构造的对象需要一个MainViewModel时，容器将使用这个实例。
这个块在init中添加了一个新的内联的MainViewModel工厂方法。这个设计保证了另一个MainViewModel不会被意外创建，因为这个工厂方法在init之外是不可访问的。
共享MainViewModel被创建并用于初始化sharedMainViewModel属性。

这是MainViewModel依赖，下一个是OnboardingViewController：





注意工厂方法是如何不再有参数的!这是因为容器中的工厂方法可以使用其他工厂方法来创建临时依赖，也因为容器中的工厂方法可以访问容器的属性来获得长期依赖。容器拥有组装整个依赖关系图所需的一切。

以下是关于上述代码需要注意的一些其他事项：
这添加了一个可选的存储属性来持有一个共享的OnboardingViewModel。这个属性是可选的，因为OnboardingViewModel只在用户未登录到Koober时才需要。此属性以空值开始。
OnboardingViewController依赖图中所有依赖项的所有工厂方法都被添加到这里。
这一行在每次创建一个新的OnboardingViewController时都会创建一个新的OnboardingViewModel。这个OnboardingViewModel存储在容器的sharedOnboardingViewModel中。OboardingViewModels是有状态的，因此，在工厂方法中创建的OnboardingViewController实例的生命周期中，应该使用相同的视图模型实例。稍后，您将看到如何通过将装入工厂方法分离到scoped容器中来改进这一点。
这一行通过使用sharedOnboardingViewModel以及OnboardingViewController需要的所有视图控制器创建了一个新的OnboardingViewController。是的，强行打开是丑陋的。在学习如何将此逻辑分离到一个限定作用域的容器时，您将看到如何消除这种情况。

MainViewModel吗?检查。OnboardingViewController吗?检查。现在我们来看看LaunchViewController:


不用惊奇。上面的代码添加了两个工厂方法:一个用于创建LaunchViewModel，然后使用它在另一个工厂方法中创建LaunchViewController。
所有的设置已经完成。唯一缺少的是一个可以创建MainViewController的工厂方法：




以下是每个部分的工作:
第一行创建了一个LaunchViewController。
看看OnboardingViewController工厂闭包是多么简单，因为OnboardingViewController工厂方法没有参数。
这就是你一直在等待的:创建MainViewController的行。这行代码使用了一个长期依赖、一个新创建的依赖和一个工厂闭包来创建一个MainViewController。所有的大概念，都集中在一行里。
此时此刻，容器已经设置好，可以开始构建Koober的对象图了。现在是最后一步——在Koober启动时创建一个MainViewController和它的整个图形:



这是不是特别简单，创建Koober的整个依赖关系图只需要两个步骤。使用上面的代码，您可以得到以下功能：
 创建应用容器，并将其存储在应用委托内的一个常量中。创建这个容器很容易，因为初始化器没有任何参数。请记住，您应该只创建容器的一个实例，因为容器与工厂类不同，是有状态的。
通过在容器上调用根对象的工厂方法来创建根对象，在本例中是一个MainViewController。这一行创建并设置了库伯运行所需的所有内容。所有依赖项都是由外部提供的。

所有这些的真正妙处是，Koober内部的所有类都不知道依赖容器。使用DI并不会将一堆东西引入到现有代码中，而这些东西以后可能会想要去掉。

这是一段多么美好的旅程啊。您已经看到了在实践中使用的三大方法。你快到终点线了!唯一麻烦的东西是可选的sharedOnboardingViewModel。当你发现自己需要强行打开某件东西时，难道你不讨厌它吗?我知道我喜欢。在下一节中，您将看到如何通过将装入工厂逻辑分离到单独的作用域容器中来解决这个问题。




上面的代码与之前的KooberAppDependencyContainer完全相同，只是没有所有的加载工厂方法，除了主要的OnboardingViewController工厂方法makeOnboardingViewController()。

这个方法将使用子加载依赖容器来创建一个OnboardingViewController。在探索了子加载容器的类之后，您将在本示例的末尾看到这个方法的实现。

接下来，您将研究一个表示装入作用域的新容器类。当Koober确定用户未登录时，Koober将转换到加载状态。这可能发生在启动或用户退出时。
面是加载时作用域容器类的样子：





下面是每个部分的工作：
这两个长期存在的依赖项由应用依赖项容器持有。这个例子不是持有应用依赖容器，而是持有长期存在的依赖本身。这样，这个加载容器中的工厂方法就可以很容易地访问长期存在的依赖项，而不需要知道如何从应用依赖容器中查找依赖项。

这一行声明了有作用域的sharedOnboardingViewModel长期依赖。这个长期存在的依赖关系只在容器存在时存在。最重要的是，注意这个属性是一个常量，而不是可选的。

这是容器的初始化式。请注意，为了创建这个加载式容器，应用依赖容器是如何被要求的。这是因为这个容器创建的对象，需要应用依赖容器持有的长期依赖项。应用依赖容器是加载容器的父容器。

这将添加一个内联工厂方法来创建一个共享的OnboardingViewModel。OnboardingViewModel是有状态的，因此需要存储在属性中。由于属性需要在初始化器中设置，OnboardingViewModel的工厂方法需要内联在初始化器中。

这些行会找到父应用依赖容器持有的长期依赖项，并使用这些依赖项在子容器上设置相应的属性。这些属性是必需的，以便加载依赖项容器能够保留这些长期存在的依赖项。保留来自父容器的依赖关系是可以的，因为父容器的寿命比子容器长。这个子容器不可能比它应该持有的时间更长。

在这里，使用内联工厂方法创建了共享的OnboardingViewModel。

下面是所有曾经存在于应用依赖容器中的工厂方法。这里唯一的区别是sharedOnboardingViewModel不再强制解包。

还有一步。回想一下，MainViewController的工厂方法需要能够在注入到MainViewController的工厂闭包中创建一个新的OnboardingViewController。
要做到这一点，工厂闭包需要实现KooberAppDependencyContainer的makeOnboardingViewController()。
下面是makeOnboardingViewController()的实现：


从应用依赖容器中创建一个新的OnboardingViewController需要两个步骤：
首先，您需要使用应用程序的父依赖容器self创建子依赖容器。
最后，使用子容器创建并返回一个新的OnboardingViewController。

好了——容器层次结构已经设置好，可以构建Koober的对象图了。现在是最后一步——在Koober启动时创建一个MainViewController和它的整个图形:

是的，这段代码一点都没变。将单个容器重构为容器层次结构不会影响消费代码。我就问你这酷不酷，这就是Koober使用DI的全部过程!

恭喜你;你坚持到了最后!通过练习本章中介绍的所有技术，您将很快成为DI大师。您在本章学到的一切都是设计良好的面向对象软件所需的基础。没错——你甚至可以在移动开发之外使用这些技术。花些时间来巩固你使用DI的舒适程度将会给你带来巨大的回报。在进入下一章之前，请确保您对DI有很好的理解，这样您就可以轻松地浏览示例代码库。

本章要点
iOS SDK是面向对象的;因此，你可以使用面向对象的技术来设计架构良好的iOS应用程序。
通过管理对象依赖关系可以实现许多有益的目标，包括可测试性和可维护性。
消费者需要在建对象和在建对象需要传递依赖关系，这些对象一起构成了一个对象图。
访问依赖项、确定可替换性和设计可替换性构成了您需要回答的三个基本问题的基础，以获得管理对象依赖项的好处。
依赖注入、服务定位器、环境和协议扩展是iOS应用开发者使用的主要依赖模式。
依赖注入(DI)就是提供来自对象外部的依赖
DI有三种类型:初始化器注入、属性注入和方法注入
您看到了如何以四种方式应用DI:按需加载、工厂、单一容器和容器层次结构。
当应用DI模式时，您的目标是构建应用程序的整个对象图，从根对象开始，通常是根视图控制器。
当构建中的对象需要创建依赖项的多个实例时，可以注入一个工厂闭包，或者注入一个符合工厂协议的对象。

接下来要做：
DI自2004年就已经出现了，但关于这个话题的深度材料并不多。您将找到的大部分内容都教你如何使用DI库。然而，这里有一些很好的资源，你可以探索以了解更多:
 Inversion of Control Containers and the Dependency Injection pattern  by Martin Fowler.这是介绍DI的原始文章。如果你想了解这个模式的起源以及它为什么会出现，这是一本书应该好好读读。
Dependency Injection in .NET by Mark Seemann， 然本书使用.net作为示例代码，但该书中内容适用于任何面向对象的语言。这可能是目前可用的最彻底的DI治疗方法。
如果您有兴趣学习如何使用库应用DI，请参阅Gemma Barlow关于Swinject的教程：Swinject Tutorial for iOS: Getting Started.

接下来你应该读哪一章?因为下一章不会建立在彼此的基础上，您可以随心所欲的读任何一章。


第五章 MVVM 架构   By Josh Berlin & René Cacheaux
	模型-视图-视图模型(MVVM)是iOS社区的新趋势，但它的起源可以追溯到21世纪初的微软。是的，你没看错!微软。微软架构师引入MVVM来简化使用可扩展应用程序标记语言(XAML)平台(如Silverlight)的设计和开发。

在MVVM之前，设计人员通过拖拽用户界面组件来创建视图，而开发人员则专门为每个视图编写代码。这导致了视图和业务逻辑之间的紧密耦合——更改其中一个通常需要更改另一个。由于这种工作流程，设计人员失去了尽情发挥的自由:他们在更改视图布局时变得犹豫不决，因为这样做通常需要开发人员重写大量代码。

微软特别引入了MVVM来解耦视图和业务逻辑。这减轻了设计师的痛苦，他们现在可以改变用户界面，而开发人员不需要改变太多代码。	
快进到今天的iOS，你会发现iOS设计师通常不会直接修改Xcode故事板或自动布局约束。相反，他们使用图形编辑器(如Adobe Photoshop)进行设计。他们将这些设计交给开发人员，开发人员反过来创建视图和代码。因此，MVVM的目标在iOS上是不同的。

MVVM并不打算允许设计师直接通过Xcode创建视图。相反，iOS开发者使用MVVM将视图与模型解耦。但好处是一样的:iOS设计人员可以自由改变用户界面，而iOS开发人员不需要改变太多的业务逻辑代码。

MVVM 是什么
MVVM是一种“响应式”架构。视图对视图模型上的更改作出反应，视图模型根据来自模型的数据更新其状态。
		

MVVM涉及三个层次：	
模型层包含数据访问对象和验证逻辑。它知道如何读写数据，并在数据更改时通知视图模型。
视图模型层包含视图的状态，并且有处理用户交互的方法。它调用模型层上的方法来读写数据，并在模型数据发生变化时通知视图。
视图层样式和显示在屏幕上的元素。它不包含业务或验证逻辑。相反，它将其可视化元素绑定到视图模型的属性上。它还接收用户输入和交互，并在响应中调用视图模型的方法。	


因此，视图层和模型层完全解耦。视图层和模型层只与视图模型层通信。					
	接下来，您将深入了解每一层。

模型层					
模型层负责所有的创建、读取、更新和删除(CRUD)操作。
你可以用许多不同的方式设计模型层;然而，最常见的两种设计是push-and-pull和observe-and-push:
push-and-pull: 设计要求消费者请求数据并等待响应，这就是pull部分。使用者还可以更新模型数据，并告诉模型层发送数据，这就是push部分。
observe-and-push:设计要求消费者“观察”模型层，而不是直接要求数据。与推拉式设计一样，消费者也可以更新模型数据，并告诉模型层“推”它。
Koober采用推拉式设计。具体来说，它使用存储库模式的实现。接下来，将对此进行更详细的讨论。

库模式
存储库包含可以调用服务器或从磁盘读取的数据访问对象。
By Josh Berlin & René Cacheaux


存储库模式为网络、持久性和内存缓存提供了façade。这个façade创建、读取、更新和删除磁盘和云中的数据。存储库不会向使用者公开它检索或存储数据的方式。

当与MVVM结合使用时，视图模型使用存储库façade，而不是自己执行这些操作。反过来，视图模型转换模型数据，并将其暴露给视图以显示在屏幕上。

库结构
存储库提供了一组异步CRUD方法。底层实现可以是无状态的，也可以是有状态的。无状态实现在检索数据后不保留数据，而有状态实现将数据保存以备以后使用。组件通常是有状态的，并将数据保存在内存中，以便快速访问。

在底层，存储库具有多层数据访问。存储库的每个实现都可以实现这些层的全部或唯一一个。

云远程api层调用服务器来读取和更新数据。这可以进行REST调用，从套接字连接或其他方式获取数据。这一层的数据总是来自应用程序外部。
持久存储层将数据放在本地数据库中。数据库可以是Core Data、Realm或磁盘上的Plist文件。这一层的数据总是来自应用程序。数据在应用程序关闭后被持久化。
内存缓存层将数据存储在对象中，这些对象在存储库的生命周期内一直存在。缓存不会在应用程序会话之间存在。内存中的缓存对于在对云进行网络调用之前显示预取的数据非常有用。

例子：KooberUserSessionRepository
在Koober中，注册或登录将创建一个新的会话。会话包含当前用户的身份验证令牌和元数据，如姓名和头像。

KooberUserSessionRepository处理Koober应用程序中所有与用户相关的活动，包括注册、登录、退出和获取当前用户。		

当一个新用户注册时，KooberUserSessionRepository调用Koober Cloud REST API，从响应中创建一个用户会话，最后将用户会话保存到一个持久存储中。

这一切都发生在被子里。KooberUserSessionRepository没有向它的消费者公开任何内部实现。特别是，KooberUserSessionRepository API没有公开任何关于数据来自哪里的信息。底层实现可以更改为调用不同的REST API，并只在内存中存储数据。如果是这样，API仍然保持不变，消费者也不会受到影响。

登录API接收电子邮件和密码，并异步返回一个用户会话对象。API的调用者只关心他们得到的是最新的用户会话。他们不关心用户会话是否来自内存存储、云API或持久存储。

存储库允许实现的灵活性，同时保持用户界面层的稳定。存储库实现可能会因新的项目需求而改变。无论实现如何，用户库方法的调用者永远不会改变。如果您的公司要求您从REST切换到协议缓冲区，您是惊慌还是保持冷静并进行重构?这种灵活性使你的应用程序更稳定，更不容易出现bug，当实现不可避免地发生变化时，需要更少的重构。

视图层			
视图是屏幕的用户界面。在MVVM中，视图层通过绑定查看模型属性来响应状态变化。它还通知视图模型用户交互，如按钮点击或文本输入更新。

视图的目的是呈现屏幕。它知道如何布局和样式化用户界面元素，但对业务逻辑一无所知。

在MVVM中，使用单向数据绑定将UI元素从视图绑定到视图模型。这意味着视图模型是真理的单一来源。直到视图模型改变其状态，视图才会更新。

视图层包含视图的层次结构。每个父视图都知道它的子视图，并可以访问它们的属性。			
	
视图模型层	
视图模型是本章中聚会的核心。它包含视图的状态、处理用户交互的方法以及绑定到不同用户界面元素的方法。

视图模型知道如何处理用户交互，比如点击按钮。用户交互映射到视图模型中的方法。这些方法做一些工作，比如进行API调用，然后更改视图模型的状态。状态更新导致视图作出反应。	

视图模型的目的是将视图控制器从视图中解耦。听说过“大规模视图控制器问题”吗?你的视图控制器文件似乎永远滚动吗?视图模型可以提供帮助。它们与视图控制器完全分离，它们对视图控制器的实现一无所知。

你可以在不改变视图模型的情况下用不同的布局替换整个视图。视图模型在可测试性方面给了MVVM很大的优势，因为您可以在没有用户界面的情况下测试它们。

Kickstarter使用视图模型编写了iOS应用程序。它有超过1000个视图模型测试。Kickstarter在其博客中写道:“我们将这些内容作为输入信号到输出信号的纯粹映射，并对其进行大量测试，包括本土化测试、可访问性测试和事件跟踪测试。”这种“纯映射”的思想是MVVM的核心。视图模型接收输入信号并产生输出信号，在视图模型和视图之间提供了清晰的边界。

接下来，您将更深入地了解视图模型的结构：		
viewstate存储在视图模型中。状态由公共的可观察属性组成。使用RxCocoa，当视图模型创建时，用户界面元素将自己绑定到可观察对象。	
方法执行任务以响应用户交互。这些方法执行一些工作，比如调用一个登录API，然后更新视图模型的状态。视图知道状态是否改变，因为可观察对象会发出新数据的信号。你通常会将任务方法标记为@objc方法，因为你必须在UI Control上对目标做出相应。
依赖项通过初始化器注入传递给视图模型。任务方法依赖于依赖关系来与应用程序中的其他子系统通信，比如REST API或持久存储。视图模型知道如何使用依赖项，但不知道底层实现。
	
视图模型有时会使用其他视图模型来改变整个应用的状态。在这种情况下，其他视图模型是使用初始化器注入的。将在代码示例部分介绍如何向其他视图模型发出信号。
			

例如:Koober登录视图模型		
登录视图模型包含用于登录到Koober的业务逻辑和用于更新状态的可观察对象。

视图模型依赖于usersessionrepository和SignedInResponder，初始化对象通过初始化器来注入它们。

usersessionrepository调用Koober登录API来使用电子邮件和密码进行身份验证。	
SignedInResponder处理成功的登录。它会发出信号，将应用状态从未登录切换到登录。

视图模型包含三个可观察对象:
emailInput和passwordInput可观察对象绑定到视图中的文本字段。每次在文本字段中输入新文本时，它们都会更新.
errorMessages可观察对象包含一个字符串列表。每次向列表中添加新字符串时，视图都会显示错误。
		
登录视图模型中唯一的任务方法是signIn()。该方法要求usersessionrepository使用emailInput和passwordInput中的值登录。如果登录成功，视图模型将向SignedInResponder提供新的用户会话。如果登录失败，视图模型将错误添加到errorMessages，视图将显示错误。

创建视图
视图知道如何样式化和布局它的子视图，以及如何将用户界面元素连接到视图模型可观察对象。

在Koober中，视图控制器在loadView()中创建视图和视图模型。视图控制器首先创建视图模型并将其传递给视图。由于Koober在代码中创建视图布局，视图可以有一个自定义初始化器。

如果您使用Interface Builder创建视图控制器和视图，视图控制器将包含隐式unwrapped视图模型变量。依赖容器会使用属性注入而不是初始化器注入等方式将视图模型注入到视图控制器中。视图控制器将视图模型传递给viewDidLoad()或awakeFromNib()中的视图。

容器视图
Koober中的每个屏幕都有一个容器视图——一个包含其他子视图的顶层视图。容器视图的目的是在模块化视图之外构建一个复杂的屏幕。不要把所有的用户界面扔到一个巨大的视图中，而是要让你的视图更小、更集中、更可重用。
容器视图中的“视图”指的是一个UIViewController及其UIView。

构建容器视图
依赖容器用它的子视图初始化一个容器视图。容器视图在视图层次结构中添加和显示子视图。

子视图受限于顶级容器视图的职责。需要的子视图的数量取决于屏幕的复杂性。每个子视图都是可重用的，并且独立执行所有的工作。

为什么不把所有东西都放在一个大型容器视图中呢?如果你不需要在应用程序的其他地方重用视图呢?视图是否可重用并不重要。重要的是将视图代码移出视图模型。这让你可以改变应用的结构，而不必改变每个视图模型中的代码。

视图模型不应该知道事物在更高层次上是如何工作的。它不应该做出假设或将自己与其他中间代码紧密耦合。这使得视图协调代码更容易更改，并允许开发人员一起工作，而不会影响到彼此。

这允许一个开发人员在单个屏幕上工作，而另一个开发人员在协调器屏幕上工作。它们甚至可以并行地进行更改，这是不是很酷!

例子:Koober骑行请求



叫车页面包含了Koober应用程序的主要内容——地图、可用的乘车选项以及接送地点的选择。如果我们在一个视图控制器中写所有这些功能，这个文件将是巨大的。



容器视图帮助我们组织所有的功能并设计每个部分独立。

map和ride-option-picker是可以独立存在的子视图。在Koober中，它们只存在于pick-me-up页面中，但它们拥有模块化视图设计的优势。一个开发人员可以构建整个地图屏幕，而另一个开发人员可以构建出行选择器。然后，pick- me-up页面将它们添加到视图层次结构的适当位置。

视图模型之间的通信
有时，当状态改变时，视图模型需要向应用程序的其他部分发出信号。如果一个任务超出了一个视图模型的职责范围，应用程序可能需要通知另一个视图模型来接管。

当视图模型发出信号时，它们传达的是发生了什么，而不是要做什么。应用程序决定做什么。这提供了灵活性——你可以改变应用程序的响应方式，而不需要改变视图模型。

协作视图模型
通常，视图模型中的状态变化会更新视图。有时候，这些状态的改变会影响整个应用程序。视图模型不知道如何发布全应用范围的通知;他们接受输入并产生输出。视图模型与应用程序通信的一种方式是调用另一个视图模型，形成视图模型的图形。

视图模型有三种相互协作的方式:
闭包:为了发出信号，视图模型接受一个闭包作为初始化器参数。当事件发生时，视图模型调用闭包。
协议:每个输出信号都用单一的方法协议建模。其他想要响应传出信号的视图模型必须符合协议。你应该对每个信号使用单一协议;否则，构造器会将所有响应逻辑放置到单个对象中。
可观察对象:对于输出信号，视图模型暴露了一个可变的可观察对象，其他视图模型可以通过推送新的状态onNext(_:)来修改这个对象。

导航


在Koober中，点击登录按钮将登录屏幕推送到导航堆栈上。

在像模型-视图-控制器(MVC)这样的体系结构中，导航这个流程是很简单的:Sign In按钮点击触发欢迎视图控制器中的一个方法，它创建了签入视图控制器，并将其推到导航堆栈上。

在MVVM中，相同的流程更加复杂。请记住，视图调用视图模型上的任务方法来完成工作——甚至是导航。点击Sign In按钮会告诉视图模型发生了什么。接下来，视图模型返回并告诉视图导航到登录页面。这种间接性很奇怪，但在纯MVVM中，用视图模型处理用户交互。

在本节中，您将了解如何驱动页面之间的导航，在导航期间管理视图状态，以及在管理导航时的范围。

模型驱动导航

在模型驱动的导航中，视图模型包含一个视图枚举，描述所有可能的导航状态。系统观察到这一点，并在值改变时导航到下一个页面。

容器视图和容器视图模型为它们的子视图处理导航。子视图模型向容器视图模型发出信号，容器视图模型在顶层处理导航

子视图可以通过两种方式发出信号：
当视图枚举值发生变化时，协作视图模型会相互发出信号。子视图模型被注入到更高层次的视图模型中，并在应该出现导航时调用任务方法。
共享的可观察对象视图状态持有一个可变的可观察对象属性和当前视图枚举值。依赖容器会用Observable主题注入子视图模型。任何子视图模型都可以推送一个新的视图枚举值。容器视图模型观察这个值，并在它发生变化时导航到下一个页面。

系统驱动导航
系统驱动的导航是由系统管理的任何导航。例如，触发滚动视图页面导航的手势，或点击导航堆栈中的后退按钮，会自动将用户导航到上一个页面。

在纯MVVM中，您将覆盖所有这些手势，而视图模型将处理用户交互。对于大多数应用程序来说，这是多余的。一个更好的选择是使用系统，并利用苹果已经为你设计的东西。一旦MVVM实现与内置的系统范型产生摩擦，请考虑使用结合了模型驱动导航和系统驱动导航的MVVM实现。

结合
您可以使用内置的、系统驱动的导航，同时仍然实现MVVM架构。例如，您可以使用模型驱动的导航向前移动导航堆栈，使用系统驱动的导航向后移动。
Koober的登录流程结合了模型驱动和系统驱动的导航。


onboarding视图模型在三种状态之间切换:欢迎、登录和注册。点击欢迎屏幕上的Sign In按钮将视图模型状态更改为“Sign In”。onboarding视图对更改作出反应，并将登录屏幕推送到导航堆栈上。点击登录界面导航栏上的Back按钮，可以使用系统驱动的导航从堆栈中弹出屏幕。

管理状态
一些导航方案在导航时创建新的视图，而其他方案保持不变，到视图上并重用它们。

在导航栏上创建新的视图
每次呈现视图时创建一个新的视图更容易管理。当视图离开屏幕时，视图和视图模型不会保存在内存中。

每次应用程序不需要视图时，系统都会释放视图。当应用程序再次创建它们时，视图模型用正确的初始状态填充视图。有了这个选项，您就不需要担心视图在屏幕外时的状态变化。



在Koober中，你可以在显示地图页面前获取用户的当前位置。

这个操作可能要花几秒钟，所以你要在进程中显示你的位置。


main-view-custom-container处理查找位置屏幕和地图页面之间的转换。它在任何转换之前创建了“寻找你的位置”和地图页面。在呈现地图后，它会销毁并释放“寻找你的位置”页面。

在导航上重用视图
当视图需要保存它们的状态时，重用视图是有意义的。系统容器，如标签栏和导航控制器，重用导航视图。

将理论应用于iOS应用
祝贺你完成了代码示例——袋鼠们也为你感到骄傲!你已经学了很多关于MVVM的理论。

现在您已经了解了MVVM的核心概念，您将在代码示例部分获得更多乐趣。

代码示例部分涵盖了MVVM在现实世界中的三个重要用例:
在构建视图中，您将学习如何创建Koober登录屏幕的模型层、视图模型层和视图层。
在组合视图中，您将学习如何在地图屏幕上请求Koober座驾。您将学习如何构建乘坐选项选择器、地图页面，以及它们如何使用视图模型相互通信。
在导航中，您将学习如何使用视图模型驱动导航，以及地图页面如何在视图之间导航。此外，您还将了解如何从地图页面以模态方式显示用户的概要信息。
是时候深入研究代码了!

建立一个视图


登录页面允许您与Koober进行身份验证。初始状态显示空电子邮件和密码字段的占位符。Sign In按钮始终处于活动状态。即使文本字段为空。点击该按钮验证电子邮件，如果任一字段为空或API调用返回错误，则显示一个错误。

当登录API请求正在进行时，屏幕会显示一个菊花并禁用用户界面。
注意:大多数代码片段都是完整文件的子集。如果你想继续阅读并查看完整的源代码,可以打开KooberApp/KooberApp.Xcodeproj。

模型层
登录模型层完成大部分身份验证工作。它使用Koober服务器进行身份验证，并持久保存用户会话。

库在KooberKit/DataLayer/ repositories中，模型在KooberKit/DataLayer/Model中。

登录模型层使用存储库模式访问数据——具体来说，是UserSessionRepository协议:


UserSessionRepository具有读取用户会话和验证用户的方法。对于登录屏幕，您将调用signIn(电子邮件:密码:)。

所有的Repository方法都返回一个带有UserSession对象的promise。您可以使用第三方框架PromiseKit来创建承诺。promise允许调用者立即从方法返回，并期待成功或失败。您将在下面的视图模型层小节中了解更多关于如何使用承诺的内容




UserSession是一个简单的类，包含一个概要文件和一个用户会话。UserProfile包含关于用户的元数据。RemoteUserSession包含一个AuthToken，一个类型化的字符串。
这就是模型层!存储库模式非常棒，因为UserSessionRepository的实际底层实现对协议方法的调用者并不重要。

你可以在KooberKit/DataLayer/Repositories/ KooberUserSessionRepository.swift中看到这个实现。存储库调用远程API，并将数据存储在数据存储中。你可以用一个假的远程API和内存存储来替换它，UserSessionRepository协议不会改变。

视图模型层
SignInViewModel是所有反应性魔术在登录屏幕中发生的地方。它保存所有视图状态，并将用户签入。

你可以在KooberKit/UILayer/Onboard/SignIn/ SignInViewModel.swift中找到视图模型。



首先，看看依赖关系:
UserSessionRepository对用户进行身份验证，正如您在上面的模型层部分中看到的那样。
SignedInResponder通过将应用状态从onboarding切换到signed in来处理成功的签入。这将导致应用程序关闭登机流程，并显示地图页面。登录视图模型并不关心切换是如何发生的——它只是告诉响应器发生了什么。


SignInViewModel包含登录视图的整个状态。视图将其用户界面元素绑定到行为主题，视图模型在内部更新它们。

emailInput和passwordInput行为主题被绑定到视图的电子邮件和密码字段。要登录，它们都必须包含非空值。
下图显示了登录流程:



视图模型告诉用户会话存储库使用电子邮件和密码值进行登录。如果成功，视图模型将通知新用户会话对象的已签名响应器。在出现错误时，视图模型用错误消息更新errorMessage行为主题。

接下来，看看登录视图模型是如何实现任务方法的：


当用户点击Sign In按钮时，登录视图调用Sign In()任务方法。该方法被标记为@objc，因为视图为该选择器的Sign In按钮添加了一个目标/操作对。

首先，该方法调用indicateSigningIn()。


indicateSigningIn方法通过将所有用户界面控件的启用行为主题设置为false来禁用它们。该方法还通过更新signInActivityIndicatorAnimating行为来显示微调项。
视图模型并不关心登录视图

如何对这些状态更改做出反应。视图可以包含一个UIActivityIndicatorView或自定义微调项。
这很酷，因为登录业务逻辑完全与用户界面实现分离。

接下来，该方法要求UserSessionRepository使用emailInput和passwordInput行为主题的值为用户签名。signIn()立即返回一个状态，该状态包含一个有效的UserSession或一个Error。

在成功的例子中，signedInResponder用新的UserSession更新应用程序。

在错误的情况下，indicateErrorSigningIn()使用生成的错误来更新应用程序。

这个错误将出现在“Sign In Failed”对话框中:





此方法通过将所有用户界面控件的启用行为主题设置为true来重新启用它们。
该方法还通过设置signInActivityIndicatorAnimating来停止旋转器的行为。


这就是整个视图模型!

还有一件事:你会注意到，当你在样例项目中查看视图模型文件时，它们都没有导入UIKit并且完全独立于UIKit。这确保你可以在不访问任何UIKit元素的情况下测试视图模型逻辑。

视图层

我们在代码中创建了所有的Koober根视图，而不是使用storyboards。是袋鼠坐骑逼我们这么做的！哈哈，这是有正当理由的。根视图在初始化时注入一个视图模型。使用storyboards，这是不可能的。而且，现在创建代码内约束要容易得多。但这是另一个问题了。

在本节中，你将学习如何在SignInViewController中创建SignInRootView。

SignInRootView是一个UIView的子类，它包含了所有的登录UI:电子邮件和密码文本字段，登录按钮和一个活动指示器。

你可以在Koober_iOS/iOSApp/Onboarding/ sign中找到View文件。





SignInViewController用loadView()中的SignInViewModel初始化它的SignInRootView。根视图知道如何将其UI元素绑定到视图模型的可观察对象上。


SignInViewModelFactory协议只有一个职责:创建一个登录视图模型。makeSignInViewModel方法返回一个随时可用的SignInViewModel。
视图控制器不知道如何创建视图模型。视图模型有视图控制器范围之外的依赖项。你把工厂注入到知道如何创建视图模型的视图控制器中。
注意:创建视图模型工厂不在本章的讨论范围内。但是，如果你想探索代码，SignInViewModelFactory的实现是在Koober_iOS/iOSApp/Onboarding/ kooberonboarddingdependencycontainer.swift。

这就是MVVM中视图控制器的职责。根视图处理用户界面的更新，而视图控制器管理视图的生命周期。

接下来，看看登录根视图:


SignInRootView有一个自定义的初始化器，它接受一个框架和一个视图模型。它使用
注入SignInViewModel，在初始化时将其UI元素绑定到可观察对象。



bindEmailField()方法将emailField文本可观察对象绑定到视图模型的emailInput行为主题。每当用户在电子邮件文本字段中输入文本时，emailInput的值就会发生变化。passwordField的行为与此相同。

bind函数使用text field‘s rx。驱动视图模型相应行为主题的文本属性。将文本字段绑定到主题意味着主题始终包含有效的文本值。如果文本为nil, map函数将返回一个空字符串，以确保该值始终有效。

接下来，让我们看看视图如何将视图模型的主题绑定到它的视图上。


绑定非常简单。视图将emailField上的isEnabled标志绑定到视图模型的emailInputEnabled主题。当emailInputEnabled改变时，emailField启用或禁用。

SignInRootView还有一件事需要完成:将SignIn按钮动作绑定到视图模型的Sign - In任务方法:


wireController()方法在视图的didMoveToWindow()生命周期方法中被调用。视图知道视图模型中的哪个任务方法来连接signInButton触摸事件。视图控制器和根视图一起组成了MVVM中的“视图”。视图控制器用它的依赖项来配置视图。视图布局和按照UI样式化的用户界面，它知道如何将用户输入绑定到正确的可观察对象。

排列视图
选择坐骑界面是Koober应用程序的核心。袋鼠们在这里跳来跳去，完成他们的拼车任务。



在这里，你选择你想要Koober载你去的地方并选择Koober驾驶类型。地图显示了您的取货和卸货地点，底部的容器显示了乘车选项选择器。

在这个例子中，你将看到在你选择了一个下车地点之后，选择一个乘车选项的流程。

你可以在KooberKit/iOSApp/UILayer/SignedIn/ PickMeUp中找到pick- me-up视图模型，在Koober_iOS/iOSApp/SignedIn/PickMeUp中找到UI。

pick- me-up 容器视图


PickMeUpViewController是一个容器视图，它有两个子视图:PickMeUpMapViewController和RideOptionPickerViewController:



PickMeUpViewController通过初始化器注入在初始化时获得它的子视图控制器和PickMeUpViewModel。它将子视图添加到视图层次结构中，但它不知道它们的实现。它只负责放置它们。

当用户与子视图交互时，子视图通知PickMeUpViewModel。它们不直接与父容器视图通信。

接下来，看看当你选择一个新的骑乘选项时，RideOptionPickerViewController如何发出信号。

出行选项选择器视图控制器



RideOptionPickerViewController在用户选择的提车位置显示可用的乘坐选项和一个确认按钮。



RideOptionPickerViewController有三个依赖项:
一个ImageCache来获得Koober骑乘类型的图标。
在特定的坐标加载乘坐选项的取车位置。
一个RideOptionPickerViewModelFactory来创建RideOptionPickerViewModel。

你会注意到pickupLocation是一个常量。如果它改变了，整个视图控制器会被销毁并再次创建



在loadView()中，视图控制器向工厂请求一个RideOptionPickerViewModel，它创建了一个RideOptionSegmentedControl。分段控件被设置为屏幕的根视图。在viewDidLoad()中，视图控制器告诉RideOptionPickerViewModel加载骑乘选项。乘坐选项会根据用户设置的上车地点而改变。

这就是视图控制器。它创建它的根视图，并在用户的提货位置加载乘坐选项。所有的用户交互都发生在根视图中，根视图与视图模型通信。

拼车选项选择器分段控制
RideOptionSegmentedControl为每个Koober乘坐选项显示一个按钮:



分段控制配置每个乘坐选项按钮，以通知RideOptionPickerViewModel当乘坐选项选择改变。每个按钮的didSelectRideOption关闭在点击时触发，它调用func select(rideOptionID: rideOptionID)与新的id。

由于视图模型被注入到视图中，它不知道底层方法实现是如何工作的。分段控件只知道如何调用视图模型的select ride-option任务方法。

乘车选项选择器视图模型
接下来，您将更深入地进入视图模型







RideOptionPickerViewModel有两个依赖项:RideOptionRepository和RideOptionDeterminedResponder。
RideOptionRepository从服务器加载骑行选项。
RideOptionDeterminedResponder更新pick-me-up视图状态与新的ride-option选择。

当乘车选项按钮调用select(rideOption: RideOptionID)时，该方法更新乘车选项按钮的isSelected状态，并告诉响应器你选择了一个新的乘车选项:


RideOptionDeterminedResponder是一个使用单一方法处理选择的协议。在底层，RideOptionDeterminedResponder是实现协议的PickMeUpViewModel。使用协议发出退出信号意味着你不必互相传递整个视图模型并公开额外的功能。
接下来，回到PickUpViewModel，看看如何使用响应器更新pick-me-up页面。

pick-me-up view model
PickMeUpViewModel使用枚举描述了pick-me-up页面的状态

PickMeUpView捕捉pick-me-up页面的所有可能状态。

Initial显示带有初始硬编码拾取位置的地图。Koober目前支持一个提货点。在此状态下，将隐藏select ride-option选择器。
selectDropoffLocation显示带有预定义的下拉位置列表的选择下拉位置选择器。
selectRideOption显示select乘车选项选择器。“确认乘坐”按钮最初是隐藏的，直到您选择一个乘坐选项。
confirmRequest显示select ride-option选择器，突出显示一个选项，以及Confirm按钮。
sendingRideRequest显示“请求乘车”屏幕。
最后取消请求骑行画面。


PickMeUpRequestProgress决定了用户的预骑请求状态。
initial(pickupLocation: Location)使用拾取位置配置初始状态。
waypointsDetermined(waypoints: NewRideWaypoints)存储了用户从列表中选择的收货和收货位置。
rideRequestReady(rideRequest: NewRideRequest)在NewRideRequest对象中存储出行选项选择和路点。



PickMeUpViewModel一旦用户选择了一个乘坐选项就会进行状态转换。




pick-me-up视图模型包含一个PickMeUpView可观察对象和一个PickMeUpRequestProgress变量。
pickUpUser(在rideOptionID: rideOptionID中)通过三个步骤处理选车选项:
创建一个NewRideRequest与选定的骑乘选项和路点。
使用新数据更新内部进度状态。
更新PickMeUpView observable到confirmrequest状态。
下图显示了整个确认请求流程:



让我们一个一个地过一遍这些步骤：
PickMeUpViewController将它的PickMeUpViewModel注入到RideOptionPickerViewController中。RideOptionPickerViewController使用PickMeUpViewModel创建一个RideOptionSegmentedControl。
当用户选择一个乘坐选项时，RideOptionSegmentedControl会告诉它的RideOptionPickerViewModel。
RideOptionPickerViewModel在PickMeUpViewModel上调用pickUpUser(inrideOptionID:RideOptionID)。
PickMeUpViewModel将其状态更改为.confirmRequest, PickMeUpViewController显示Confirm按钮
这就是pick-me-up的页面!当骑行选项选择改变时，PickMeUpViewController屏幕依赖它的RideOptionPickerViewController子视图控制器向视图模型发出信号。这种职责分离让PickMeUpViewController专注于更高级的任务，比如在屏幕上布置子节点，以及在PickMeUpViewModel状态改变时显示正确的用户界面。

导航
本节将介绍导航。您将学习驾驶导航的不同技术，如何管理导航上的初始视图状态，以及在从登录到登录过渡时管理范围。

驾乘导航
Koober使用了三种主要的驾驶导航技术:
模型驱动导航:在用户界面中查看模型状态变化驱动转换。
系统驱动导航:内置的UIKit组件驱动导航。
模型驱动和系统驱动导航的结合。

模型驱动的导航
从映射到下拉选择屏幕以及从下拉选择屏幕返回到映射的转换使用模型驱动的导航。



在初始状态下，pick-me-up页面会显示你的骑乘地点，但没有放车地点。点击“去哪里?”按钮打开一个页面，选择放置位置。

在您选择一个位置之后，该屏幕将自动退出，而“pick-me-up”页面将显示所选的下车地点以及乘车选项选择器。

pick-me-up视图模型在KooberKit/iOSApp/UILayer/SignedIn/ PickMeUp，用户界面在Koober_iOS/iOSApp/SignedIn/PickMeUp。

pick-me-up视图模型更改当前视图状态，由视图执行导航。您可能还记得来自组合视图部分的PickMeUpView枚举。



PickMeUpViewModel包含一个PickMeUpView行为主题。它会在视图状态改变时更新。PickMeUpViewController观察变化并通过导航到下一个屏幕做出反应。
视图模型的pick- me-up视图从初始状态开始，当用户点击Where to?按钮。


视图将Where to?按钮到视图模型的showSelectDropoffLocationView()方法。


showSelectDropoffLocationView()将视图模型的视图行为主题状态更新为. selectdropofflocation。
接下来，让我们看看视图控制器是如何观察状态变化的。





PickMeUpViewController订阅view的可观察属性，并在状态改变时调用present(_ view: PickMeUpView)。

当视图状态切换到selectDropoffLocation时，视图控制器调用presentDropoffLocationPicker()。它创建并呈现一个新的DropoffLocationPickerViewController。

就是这样!视图模型更新视图的当前状态，视图对状态的变化做出反应。

解除DropoffLocationPickerViewController遵循相同的模型驱动导航模式:





视图模型有一个任务方法来选择下拉位置:select(dropoffLocation: NamedLocation)。当用户选择下拉位置时，视图控制器调用任务方法。
pick-me-up视图控制器仍然需要知道什么时候消失选择下拉位置屏幕。为了实现这一点，DropoffLocationPickerViewModel需要通知PickMeUpViewModel。

来看看drop-off location-picker视图模型：


DropoffLocationPickerViewModel用一个DropoffLocationDeterminedResponder初始化。这实际上是一个符合responder协议的PickMeUpViewModel。这允许这两个视图模型相互通信。

当用户选择放置位置时，放置位置选择器视图模型在其响应器上调用dropOffUser(at location:)。

接下来，看看PickMeUpViewModel是如何响应新的投递位置的:



当用户选择一个新的放置位置时，PickMeUpViewModel将viewSubject状态更新为.selectRideOption:



最后，视图控制器对状态的改变做出反应，取消选择下拉位置屏幕，并显示乘坐选项选择器。

这是一个显示整个掉落位置选择流程的图表:


一步一步来:
PickMeUpViewController将它的PickMeUpViewModel注入到droppofflocationpickerviewcontroller中。DropoffLocationPickerViewController使用PickMeUpViewModel创建了一个DropoffLocationPickerContentRootView。
DropoffLocationPickerContentRootView告诉它的DropoffLocationPickerViewModel当用户选择一个新的下拉位置。
DropoffLocationPickerViewModel在它的PickMeUpViewModel上调用dropOffUser(atlocation:Location)。
PickMeUpViewModel将其状态更改为.selectrideoption，而PickMeUpViewController则会销毁页面。

模型驱动的导航将子视图控制器从导航流中解耦出来。子视图独立运行，通过调用视图模型上的任务方法来指示用户交互。容器视图控制器处理高级导航。

系统驱动导航
Koober在应用中的没有使用纯粹的系统驱动的导航。所以先离开Koober的领域，看看一个简单的UITabBarController示例。

注意:本例中的Xcode项目在tabbareexample / tabbareexample .xcodeproj中。

UITabBarController包含两个子视图控制器。标签栏控制器将它的选择视图控制器设置为第二个子控制器。

标签栏使用系统驱动的导航在它的子视图控制器之间切换。标签栏在它的整个生命周期中保持firstViewController和secondViewController。当selectedViewController改变时，标签栏处理到正确视图控制器的转换。

好的，让我们返回Koober.

结合
登录页面使用模型驱动的导航从欢迎页面到登录页面，它使用系统驱动的导航向后到欢迎页面。



你可以在KooberKit/iOSApp/UILayer/Onboard找到onboarding视图模型，在Koober_iOS/iOSApp/ onboarding找到UI。



NavigationAction通知视图它是否需要显示，或者是否已经完成显示。这允许视图在导航转换完成时更新用户界面。


OnboardingView有三种可能的状态:欢迎、登录和注册。

OnboardingViewController可以显示欢迎屏幕，登录屏幕或注册屏幕。



OnboardingViewModel在视图状态改变时更新OnboardingView观察对象。OnboardingViewController订阅这个可观察对象来显示下一个屏幕。


当一个新页面显示给用户时，视图控制器调用uipresenting (onboardingView: onboardingView)方法:





OnboardingViewController订阅OnboardingViewModel当前的OnboardingView可观察状态。视图控制器调用present(view: OnboardingView)将下一个视图控制器推到导航堆栈上。

在当前，签入视图控制器被推到UINavigationController堆栈。此时，系统控制导航。

当用户在登录屏幕上点击Back按钮时，onboarding视图控制器不处理向后导航。


登录屏幕结束后，OnboardingView状态仍然需要更新到.welcome。Onboarding视图控制器使用UINavigationControllerDelegate方法更新状态:





Onboarding视图控制器更新状态任何时候一个视图控制器被显示在导航堆栈上。onboardingView(associatedWith: UIViewController)方法根据视图控制器的类型返回视图状态。在向后过渡到欢迎屏幕之后，视图模型视图状态被设置为.welcome。

管理状态
当您在页面之间导航时，有两种方法来管理状态：
每次应用程序呈现一个新页面时，创建一个新视图。
在应用程序显示页面时重用视图。

导航的新视图
每次呈现一个新页面时创建一个新视图会使状态管理更容易。保证页面每次显示时都从初始状态开始。

应用程序的主导航，从获取位置页面导航到接机页面，再到等待接机页面，就是在导航上创建新视图的一个例子。



SignedInViewController是GettingUsersLocationViewController, PickMeUpViewController, WaitingForPickupViewController之间的驱动导航。

你可以在Koober_iOS/iOSApp/Onboarding/SignIn中找到视图控制器文件:


SignedInViewController使用工厂来创建它的子视图控制器。每次SignedInView状态改变时，SignedInViewController都会调用present(_ view: SignedInView)方法。

在状态改变时，SignedInViewController销毁并释放当前子进程。然后，它在屏幕上添加下一个子程序。子节点只在需要的时候被实例化——没有人持有对前一个子节点的引用。

注意:remove(_:)和addFullScreen(_:)调用子视图控制器上的视图控制器包含方法。

在导航上重用视图
在导航中重用视图使得状态管理更加困难。每次呈现一个新页面时，都需要确保状态被重置回原始状态。

登录流程是在导航上重用视图的一个例子。

OnboardingViewController驱动导航从WelcomeViewController到SignInViewController。正如你在上面的驾驶导航-组合部分看到的，OnboardingViewController最初显示一个WelcomeViewController。OnboardingViewController在用户点击登录按钮时将一个SignInViewController推送到导航堆栈上。

你可以在Koober_iOS/Onboarding中找到视图控制器文件:

UINavigationController在向后移动时重用视图。OnboardingViewController持有一个对欢迎视图控制器的引用，同时显示登录视图控制器。当用户点击Back按钮时，导航堆栈不会创建一个新的欢迎页面。

当导航堆栈弹出登录页面时，onboarding视图控制器必须确保欢迎页面处于正确的状态。

管理范围:登录页到登录成功页
在登录流程中，不存在通过身份验证的用户。没有理由创建映射，因为映射需要经过身份验证的用户才能工作。

当用户登录时，将范围从未经身份验证切换到已身份验证。在这一点上，你可以销毁和释放所有的登录页面，并创建一个新的地图页面。



你可以在Koober_iOS/iOSApp和Koober_iOS/iOSApp/ Onboarding中找到视图控制器文件:


MainViewController驱动在OnboardingViewController和SignedInviewController之间导航，将应用从onboarding状态移动到签入状态。 
OnboardingViewController包含欢迎、登录和注册页面。


在登录流程中，登录成功并不存在。该页面需要一个有效的用户会话作为依赖项—在加载流程中，没有有效的用户会话存在。

MainViewController呈现一个新的OnboardingViewController后，MainViewController从视图层次结构中移除并释放任何以前的SignedInViewController。这种情况可能发生在退出过程中:





当用户登录时，MainViewController创建一个全新的SignInViewController。然后，MainViewController从视图层次结构中移除任何之前的OnboardingViewController。

当应用程序从非身份验证的范围切换到身份验证的范围后，只有SignedInViewController存在。对于存在于未验证作用域中的任何UI，应用程序将其拆除并释放。

关键点
模型层读写数据到磁盘，并告诉视图模型数据何时发生了更改。
视图模型层包含所有视图层的状态并处理用户交互。视图模型监听模型层中的变化，并更新其状态。
当视图模型的状态发生变化时，视图层会做出反应，并在用户与视图模型的组件进行交互时告诉视图模型。
存储库是用于网络和持久性的façade。视图模型使用存储库进行数据访问，而不是执行操作本身。
视图层和模型层完全解耦。它们各自只与视图模型层通信。

MVVM 的优缺点
mvvm的优点
视图模型逻辑很容易独立于用户界面代码进行测试。视图模型不包含任何只包含用户界面的业务和验证逻辑。
视图和模型彼此完全解耦。视图模型分别与视图和模型通信。
MVVM有助于并行化开发人员的工作流程。一个团队成员可以构建视图，而另一个团队成员构建视图模型和模型。并行化任务可以极大地提高团队的生产力。
虽然MVVM本身不是模块化的，但它并不妨碍模块化结构的设计。你可以使用容器视图和子视图构建模块化UI组件，只要你的视图模型知道如何相互通信。
视图模型可以跨苹果平台(iOS, tvOS, macOS等)使用，因为它们不需要导入UIKit。特别是当视图模型是细粒度的。

MVVM的缺点：

RxSwift有一个陡峭的学习曲线(与MVC相比)。新的团队成员需要学习RxSwift，以及如何正确使用视图模型。一开始开发时间可能会变慢，直到新的团队成员跟上进度。
典型的实现需要视图模型进行协作。当使用协作视图模型时，在应用程序中管理内存和同步状态更加困难。
业务逻辑不能从不同的视图中重用，因为业务逻辑在视图特定的视图模型中。
苹果在iOS上没有像macOS上那样提供绑定机制。
它很难跟踪和调试，因为UI更新是通过绑定而不是方法调用实现的。
视图模型具有UI状态和依赖关系的属性。这意味着视图模型可能很难阅读，因为状态管理与副作用和依赖关系混合在一起。

下一步是干啥
Koober是一个真实的用例，在示例项目中有大量的代码，我们无法在一章中介绍。您可以自己探索代码库。
这里有一些地方可以看看:
看看登录后依赖容器是如何在Koober_iOS/ iOSApp/SignedIn/KooberSignedInDependencyContainer.swift中创建的。容器创建所有需要经过身份验证的用户会话的页面。
在Koober显示地图之前，您必须获取用户的当前位置。在导航到地图之前，遵循显示“获取您的位置”屏幕的流程。查看:
导航的Koober_iOS/iOSApp/SignedIn/SignedInViewController.swift。
KooberKit / UILayer SignedIn / GettingUsersLocation / 用于获取位置逻辑的GettingUsersLocationViewModel.swift。
Koober_iOS / iOSApp SignedIn / GettingUsersLocation /用于调用视图模型的任务方法	   	

看看投递地点选择器搜索是如何工作的。下拉位置选择器视图控制器包含一个自定义的可观察搜索UI控制器，它将搜索输入绑定到下拉位置选择器视图模型。视图模型使用存储库获取新的位置，并更新其搜索结果状态。下面是文件地址：
视图模型: KooberKit/UILayer/SignedIn/PickMeUp/SelecDropoffLocation/ DropoffLocationPickerViewModel.swift。
视图：Koober_iOS/iOSApp/SignedIn/PickMeUp/SelectDropoffLocation/ DropoffLocationPickerContentViewController.swift。

第六章  Redux 架构

历史回顾

几年前，Facebook桌面网页应用的一个漏洞引发了一种新的架构。该应用程序在多个视图中同时显示Messenger的未读消息数，但是未读消息却显示不相同。这可能会不同步，报告不同的数字，所以应用程序看起来是有bug的。Facebook需要一种方法来保证数据的一致性，因此，一个新的单向架构诞生了——Flux。

在Facebook转向基于Flux的架构后，显示未读消息数量的视图从同一个容器中获取数据。这个新的架构修复了很多这类错误。

Flux是一个模式，而不是一个框架。2015年，Dan Abramov和Andrew Clark创建了Redux，作为一个受Flux启发的架构的JavaScript实现。从那以后，其他人用Swift和Kotlin等语言创建了Redux实现。

Redux 是什么？
Redux是一种架构，在这种架构中，应用程序的所有状态都存在于一个容器中。更改状态的唯一方法是基于当前状态和请求的更改创建一个新状态。


Store保存应用的所有状态。

Action是描述状态变化的不可变数据。

Reducer使用当前状态和一个动作来改变应用的状态。

store (可以理解为仓库)
Redux商店包含驱动应用程序用户界面的所有状态。把商店想象成你的应用的一个活快照。任何时候它的状态改变，用户界面都会更新以反映新的状态。

你可能会认为把所有东西都存储在一个地方是疯狂的——这是一个合理的想法。与其为state创建一个巨大的文件，不如将其分割成不同的子state。无论如何，每个屏幕都只关心整个应用状态的一部分。我们将在本章的示例代码部分详细讨论如何组织store。

state 类型
Store包含代表应用程序用户界面(UI)的数据。下面是一些例子:
视图状态决定显示、隐藏、启用、禁用哪些用户元素，或者转轮是否正在动画。
导航状态决定向用户显示哪个视图，以及当前显示哪些视图。
web服务的数据包括来自REST API的响应。响应被解析为模型并放置在存储中。在Koober，地图上显示的可用乘坐选项都在商店中。
格式化字符串是从API的原始模型数据转换为显示的字符串。

store是应用的真实来源。所有视图都从同一个store获取数据，所以不可能有两个视图显示不同的数据，就像在Facebook漏洞期间发生的那样。

数据产生
该存储不包含较大的文件，如图像或视频。相反，它包含指向磁盘上媒体的文件url。

整个store一直都在内存中。如果你的应用store中有大量的视频文件或图像，而不是文件引用，iOS可能会让你的应用崩溃以释放内存。

构建视图状态
在Redux架构中，视图不存储状态。他们只会倾听和回应状态的变化。因此，任何改变视图行为的状态都存在于存储中。存储由不可变的值类型组成。当存储中的数据发生变化时，视图将获得一个新的、不可变的状态来重新呈现用户界面。

登录页面

Onboarding显示一个欢迎页面，您可以导航到登录或注册页面。应用程序的状态决定了当前哪个屏幕显示给用户。当应用程序的状态改变时，应用程序会向用户呈现一个新的页面。


Onboarding状态显示用户登录前未经身份验证的屏幕，sign In状态显示用户登录后经过身份验证的屏幕。

Onboarding state包含三种状态:
欢迎
登录中
注册中

欢迎显示欢迎屏幕，其中有Sign In和Sign Up按钮。当你点击“登录”按钮时，你将应用程序状态设置为“登录”。当你点击“注册”按钮时，你将应用状态设置为“注册”。

在任何时候，您都可以查看Redux存储的状态，以确定用户界面呈现的页面。

加载和呈现初始状态
Koober有两种高级应用状态:
启动加载应用程序需要运行的任何数据，就像之前的用户会话。
Running显示登机流程或地图页面。

运行状态有两个子状态:
Onboarding显示登录或注册页面，以便用户进行身份验证。
sign In显示映射，需要一个有效的用户会话。

koober开始处于“登录”状态。

一旦“启动”状态读取用户会话，应用程序转换到“运行”状态。然后，用户界面显示登录流或登录页面。Redux存储总是有一个初始状态。Redux强制你声明应用程序的每一个可能的状态。

如果在两次启动之间不保存数据，则该数据必须在存储中有一个初始默认值。例如，你可以在请求搭车前选择Koober提供的乘坐选项:Wallaby、Wallaroo和Kangaroo。这些值可以更改，因此它们来自服务器。在下载它们之前，Redux存储中的初始状态是一个空数组。用户界面应该能够优雅地处理这种空状态。

订阅
对于要呈现的视图，它会订阅商店中的更改。每次状态发生变化，整个状态就会发生大规模的变化——没有中间立场。这与MVVM不同，在MVVM中，每次操作一个属性。

使用Focused Observation，视图可以订阅它感兴趣的状态块，避免在任何应用状态发生变化时进行更新。视图仍然在一次更新中获得状态块。

每次视图加载时，视图都需要从存储区获取当前状态。在加载时，它们总是处于空状态。在订阅了商店之后，它会触发更新并重新呈现视图。

当应用程序在屏幕上显示视图和订阅启动第一次更新之间有一个短暂的延迟。持续时间通常很短，你不会注意到第一次更新。但要确保所有视图都能优雅地显示空状态。

响应用户交互
动作是描述状态变化的不可变数据。当用户与用户界面交互时，产生操作。

分派操作是在Redux存储中更改状态的唯一方法。没有哪个视图能够抓取store并做出改变而不被应用的其他部分发现。Redux之所以有效，是因为操作会改变strore，它会通知整个应用程序的订阅者。

例如，在欢迎屏幕中，有两个按钮，Sign in和Sign Up。当点击“注册”按钮时，您创建并调度一个“转到注册”操作。store更新它的状态，并且通知OnboardingViewController。然后，OnboardingViewController将注册页面推送到导航堆栈上。

Reducers描述可能的状态变化。Reducers是分派操作和更改store状态之间的步骤。一个动作发出后，它通过一个reducer传递。store的状态唯一可以发生变化的地方是在一个reducer中。Reducers是一种自由函数，它接受当前存储的状态以及描述状态的动作。它们根据动作改变当前状态的副本，并返回新状态。reducer功能不应引入副作用。它们不应该在其作用域之外进行API调用或修改对象。

koober在reducer里有很多逻辑。保持视图控制器小已经够麻烦的了，最不需要的就是一个巨大的reducer文件。

Redux建议将reducers分成sub-reducers。sub-reducers有助于保持您的reducers逻辑集中和可读。Koober为用户登录流程，注册界面，登录界面等等设置了sub-reducers。

线程
在Redux中，在同一个线程上运行所有reducers是很重要的。它不一定是主线程，而是相同的串行队列。

如果您在多个线程上运行reducer，那么当reducer在另一个线程上运行时，它的输入状态可能会改变。Redux在设计上是一个同步点。

Swift是Swift中单向数据流架构的Redux实现，允许你在任何串行队列上运行reducers，但默认为主队列。最简单的方法是在主队列上运行，因为用户界面和存储完全同步。然后，在观察store时，不需要跳转到主队列。

注意:在复杂的应用程序中，reducers可能需要一些时间。在这种情况下，在不是主队列的另一个串行队列上运行reducer可能是一个好主意。大多数时候，主队列是好的。

执行的副作用
副作用是任何非纯函数。任何时候调用一个函数，在给定相同的输入时返回不同的值，这都是一个副作用。纯函数是确定的。给定相同的输入，函数总是有相同的输出。

Reducers应该是纯函数，没有副作用。在Redux中，在分派操作之前和store更新之后处理副作用。

例如，应用程序通常会对服务器进行异步API调用并等待响应。在Redux中，永远不要在reducer函数中调用这些异步API。相反，应该为网络请求的不同阶段创建多个操作。

网络请求的阶段:
网络请求正在进行中。
网络请求成功完成。
网络请求失败。

在启动网络请求之前，分派一个正在进行中的动作。reducer更新存储库中的状态，以指示正在进行中的网络请求。视图更新它的用户界面以反映变化，显示一个微调器并在需要时禁用UI元素。

接下来，发出网络请求。一旦API调用完成，就分派一个网络请求成功或网络请求失败的动作。商店更新其状态，视图更新以显示成功或失败的消息，并启用其UI元素。您还可以在网络请求期间调度操作，以更新store中的完成百分比状态。

网络请求是异步操作的一个例子，任何异步任务都可以遵循相同的流程:在任务完成之前、期间和之后调度操作。

渲染更新
Redux是一种“响应式”架构。“反应性”这个词现在经常出现。在Redux中，“反应性”意味着视图通过订阅接收更新状态，并对更新做出“反应”。视图从不向store请求当前状态;它们只在存储触发数据更改的更新时进行更新。

Diffing
每次视图通过订阅接收到新状态时，它就会获得整个状态。视图需要找出发生了什么变化，然后正确地呈现更新。

简单的解决方案是重新加载整个UI，尽管这可能看起来很笨拙。另一个解决方案是将新状态与UI的当前状态区分开来，并呈现必要的更新。

区分有助于避免不必要的更改。它还允许视图对更改进行动画处理，因为您确切地知道哪些用户界面元素更改了。

UIKit有时不会呈现不必要的更改。你可以通过子类化一个UIView来测试它，设置一个属性为一些测试值，并检查系统调用draw rect或需要显示。

例如:从登录前到登录后
Koober有两种高级应用状态:
Onboarding在用户未通过身份验证时显示登录或注册页面。
Signed-in显示用户登录后的地图屏幕。

Koober在主视图中处理从登录前到登录后的转换——主视图是一个可以显示登录屏幕或地图屏幕的容器视图



来看看登录步骤:
主视图最初显示登录屏幕。
用户输入电子邮件和密码，然后点击登录按钮。
sign -in视图告诉它的用户交互对象将用户登录到Koober。
用户交互对象要求其store进行登录API调用。
一旦API调用完成，用户交互对象将分派一个包含新用户会话的登录后操作。
Store通知主视图转换到登录后并显示映射。

store通知主视图转换到登录后并显示映射。

例如:登录
登录页面包含用户名/电子邮件文本框，密码文本框和登录按钮。点击Sign In按钮，使用用户名和密码输入登录app。



如果登录成功，将分派包含新用户会话的操作。如果登录失败，将分派包含要显示的Error消息的操作。

登录状态包含四个布尔值和错误消息:
电子邮件输入启用。
启用密码输入。
登录按钮已启用。
登录活动指示器动画。
显示错误列表。

登录页面在用户交互时分派操作，这将更新存储中的登录状态。Redux广播新的状态，登录页面通过更新其用户界面做出反应。

登录页面可以分派四个动作:
登录以表示正在进行登录操作。
登录失败，提示登录失败和错误消息。
提示错误完毕，提示用户已确认错误。
通过有效的用户会话表示登录成功。

让我们更详细地了解每一个。

在用户输入用户名和密码，并点击Sign In按钮后，将发送Signing In Action。



在调用Koober API进行登录之前，将分派登录操作，并且减速机将更新store的状态。

然后，store通知视图状态已更改为登录成功。



在Koober API从登录调用返回一个失败的响应后，将发送登录失败的操作。状态更改包括要显示的视图的错误消息。




在视图拒绝错误消息后，错误动作的呈现完成。当您希望在页面上显示错误时修改用户界面时，此状态非常重要。您还可能希望仅在用户拒绝第一个错误后才显示第二个错误。

在Koober API返回一个成功的响应后，将发送成功的动作。在这种状态下，登录页面可以转换到包含有效用户会话对象的成功状态。


在用户成功登录到Koober后，登录页面不再承担任何责任。主视图将应用程序从未经身份验证的状态转换到身份验证的状态，并显示地图页面。

将理论应用于iOS应用
如果我们不得不猜测，您可能已经准备好接受一些充满Kangaroo-filled示例的理论了!让我们深入研究代码，看看Redux在实践中是如何工作的。

Redux在iOS应用

Swift和Katana是两个主要的Swift Redux实现。两者都在GitHub上有很强的追随者，是你的Redux库的好选择。Redux是一个简单的概念，您可以编写自己的Redux库。所有的Redux库都设计得非常小。无论哪种方式，都建议使用。

koober使用swift，因为它是最成熟的库。有关swift的更多信息，请查看GitHub回购网站https://github.com/ReSwift/ReSwift。

注意:大多数代码片段都是完整文件的一部分。请随意打开06- architecture-redux/final/KooberApp/KooberApp.Xcodeproj，如果你想继续阅读并查看完整的源代码。

建立一个视图
要想在悉尼骑上袋鼠，你得先在koober登记。你在登录界面上登录应用程序，其中包含一个电子邮件字段，密码字段和一个登录按钮。



点击“登录”按钮，就可以调用kooberAPI进行身份验证，然后登录到应用程序中。

视图控制器
让我们看看SignInViewController的初始化器:



SignInViewController有两个初始化项依赖:
RxSwift可观察对象订阅SignInViewControllerState的变化。
对象来处理SignInRootView中的用户交互。
你会注意到在视图控制器中没有swift依赖项。你应该将swift从视图控制器中抽象出来，这样你就可以在不需要折射视图层代码的情况下更改库或范例。本部分将指导您如何做到这一点。

登录视图状态：
点击Cmd+Shift+O并输入文件名，在KooberKit中打开SignInViewControllerState.swift:


SignInViewState描述了SignInRootView的所有状态。前三个布尔值决定用户交互在根视图中是否可行。signInActivityIndicatorAnimating值决定活动指示器是旋转还是隐藏。


SignInViewControllerState封装了根视图状态和错误处理。
视图控制器得到它自己的状态，因为它使用视图控制器表示api来呈现错误。
如果有多个错误消息要连续显示，则错误消息是一个集合。

登录用户交互
signinuserinteraction协议描述了登录页面中可能的用户交互:


用户可以在输入电子邮件和密码后点击sign in按钮进行登录。一旦用户点击这个按钮，就会调用signIn(email:password:)方法。

如果登录失败，视图控制器在屏幕上显示一个错误。在用户解除错误后，或者错误在一段时间后解除，就会调用finishhedpresenting(_:)方法。

应用程序状态
SignInViewControllerState单独地描述登录页面。但这个state是一个更大的state树的一部分。

用户可以在输入电子邮件和密码后点击sign in按钮进行登录。一旦用户点击这个按钮，就会调用signIn(email:password:)方法。

如果登录失败，视图控制器在屏幕上显示一个错误。在用户解除错误后，或者错误在一段时间后解除，就会调用finishhedpresenting(_:)方法。

登录视图控制器不知道这些方法的底层实现。视图控制器在初始化时获得一个具体的signinuserinteraction实例。

你可能还记得在Example: Onboarding to signed in部分，Koober有两个高级的应用状态。

在Onboarding状态下，用户未经身份验证，Koober可以显示注册或登录页面。



在“已签名”状态下，用户已经在注册或登录流中进行了身份验证。


AppRunningState描述应用程序的高级状态。每个状态都有自己的子状态，子状态包含额外的信息。
让我们先来看看OnboardingState:



Onboarding flow有三种状态:
欢迎显示欢迎页面，可以导航到注册或登录页面。
登录允许您以现有用户的身份登录。SignInViewControllerState描述独立于登录页面的可能状态。上面在登录视图状态中描述了这些。
注册可以让你以新用户的身份注册。SignUpViewControllerState描述了隔离到注册页面的可能状态。
签入状态是经过身份验证的状态，您可以在这里请求地图上的Koober。在.signed应用程序运行状态中，状态的重要部分是UserSession。



UserSession对象包含有关当前经过身份验证的用户的信息，如身份验证令牌、名称和头像URL。

签入状态总是有一个有效的用户会话—-它是. signedin状态的依赖项。如果用户退出，用户会话将被销毁，应用程序将切换回.onboarding状态。

Equatable状态模型

为了防止重复调用，让你的状态模型是平等的。否则，可能会出现对UI方法的多个调用。例如，你可以一遍又一遍地呈现一个视图控制器——这不是一个很好的用户体验!

确保您的状态枚举与关联值在比较时行为正常。Swift 4.2处理大多数模型的自动合成Equatable和Hashable。

使用RxSwift
Koober从所有用户界面代码中提取了swift依赖关系，包括UIViewControllers和uiview。这使得在后续过程中切换Redux实现变得更容易，因为无需更改任何用户界面代码。不过，库伯仍然可以从斯威夫特那里得到好处。它仍然在纯减速函数中调度动作和改变状态。区别在于RxSwift驱动用户界面更新，而不是swift存储订阅。

RxSwift代理
Koober不是直接订阅商店，而是将swift商店订阅转化为RxSwift可观察对象。为了实现这一点，一个代理将swift store订阅用户的更新转发给RxSwift observer:





StoreSubscriberRxProxy处理swift store订阅。在订阅了store之后，当状态发生变化时，Redux调用newState(state:)并将其转发给观察者的on(_:)方法。

在swift store的扩展中创建可观察对象:



首先，该方法创建一个StoreSubscriberRxProxy，每当State更改时调用它。接下来，创建一个Disposable，用于在RxSwift订阅被取消时处理来自存储的取消订阅。然后，makeObservable()创建并返回可观察对象。这个可观察对象被注入到视图控制器中，并在存储状态改变时被触发。

聚焦的可观察到
每个视图只关心Redux存储状态树的一个子集。例如，用户配置文件页面显示用户信息，对地图一无所知。当用户的位置发生变化或有更多袋鼠可供乘坐时，商店没有必要通知用户资料页面。

配置文件屏幕只需要在用户配置文件数据更改时重新呈现。



现在的流程是这样的:


让我们按照代码路径来创建用户配置文件屏幕的重点可观察对象:


ProfileContentViewController有两个依赖项:
一个ProfileViewControllerState的可观察对象，是Koober的一个小子集AppState。
一个profileuserinteraction用来处理用户交互，比如退出和关闭屏幕。

swift只允许您使用Subscription类上的select()方法订阅Store的一个子集。当你订阅Redux Store而没有使用select()时，你订阅了整个应用程序的状态。

对于ProfileContentViewController，你只能从较大的AppState中“选择”ProfileViewControllerState来创建可观察对象。

可观察对象是在Koober_iOS目标中创建的。具体来说，在KooberSignedInDependencyContainer中。这个依赖容器在已验证的应用状态下创建可观察对象和其他视图控制器依赖。你可以在Koober_iOS/iOSApp/SignedIn/ KooberSignedInDependencyContainer.swift找到完整的实现



这个方法类似于RxSwift代理部分中的makeObservable()。不同之处在于，这个方法传入一个自定义订阅来创建可观察对象。这个自定义订阅“选择”了ProfileViewControllerState，并且这个可观察对象只有在状态改变时才会被触发。

作用域的状态
当使用枚举建模应用程序状态时，视图可能会观察状态超出范围。当enum大小写发生变化时，状态树的某些部分将消失。例如，在pick-me-up流程中，有一个enum用于用户所参与的乘坐请求的步骤。随着用户在用例中移动，任何在更改的用例中观察到关联值的东西都超出了作用域。在实践中，您永远不希望观察超出范围的状态。超出范围意味着视图控制器的寿命比你设计它的寿命长。

在超出范围时进行检测的能力有助于检测bug。作用域是必要的，因为可观察对象在enum情况下观察关联的值，并且当该情况不再被设置时，可观察对象必须能够处理。

你可以让可观察数据类型是可选的，但这样你的视图控制器就可以跨作用域存在。一个用户的视图控制器可以在注销和登录后突然为另一个用户发送数据。到处处理可选case也是一件痛苦的事情，并且会使代码的可读性降低。

一旦视图控制器正在观察的状态超出作用域，可观察对象就完成了——不再有事件流经它:



Koober中的可观察对象观察ScopedState，它返回.outOfScope或封装在.inScope状态中的StateType:



当ProfileViewControllerState observable被依赖容器创建时，它会观察getProfileViewControllerState(appState:)方法返回的值。

如果signedInViewControllerState不存在，这个可观察对象就不会被触发。如果signedInViewControllerState存在，可观察对象会用新的ProfileViewControllerState值触发。

用户会话持久性
Koober在会话之间将用户会话保存在磁盘上。在启动时，应用程序从持久性中读取它。如果存在，则对用户进行身份验证，并可以请求乘车。如果它不存在，用户就必须经历新登录流程。

LaunchViewController处理应用程序的初始启动。因为读取用户会话的操作是异步的，所以启动页面一直显示到它完成。

MainViewController处理LaunchViewController, OnboardingViewController和SignedInViewController之间的转换。
首先，MainViewController展示了LaunchViewController:



LaunchViewController有一个launchinguserinteraction，它在launchApp()中执行初始的应用程序设置。该对象还可以处理finishedPresenting(errorMessage:)中的错误。

LaunchViewController在加载后立即调用launchApp()。
reduxlaunchinguserinteraction是launchinguserinteraction的具体实现:




用户交互对象从注入的UserSessionDataStore中读取loadUserSession()中的持久化用户会话。

如果读取用户会话没有错误，它将被传递给finishedLaunchingApp(userSession:)。如果找到用户会话，这个方法将分派一个FinishedLaunchingApp操作，如果没有找到则为空。

在方法结束时，用户交互对象请求UserSessionStatePersister开始将更改持久化到用户会话。当用户登录或注册时，持久化程序将用户会话保存到磁盘。当用户退出时，持久化程序从数据存储中删除用户会话。

应用程序需要首先在reduxlaunchinguserinteraction中从磁盘加载初始状态。

让我们看看持久化是如何初始化的:




持久化是用一个存储创建的，它在init上创建一个AuthenticationState可观察对象来监视用户会话的变化。直到startPersistingStateChanges(to:)被调用，persistent才会订阅这个可观察对象。

可观察对象在订阅时发出当前状态，我们不想持久化已经存在的状态。可观察对象需要一个.skip(1)来跳过第一个状态事件:



这个方法订阅了authenticationStateObservable，并在认证状态改变时更新UserSessionDataStore。

以下是用户会话持久化流程的图表:



让我们回顾一下每一步:
启动视图控制器在它的用户交互对象上调用launchApp()。
启动用户交互从store中加载用户会话。
加载完成后，用户交互对象告诉持久化对象开始将用户会话更改保存到strore中。
持久化器开始观察AuthenticationState可观察对象。
每当身份验证状态发生变化时，持久化程序就会从store中保存或删除用户会话。

就是这样!persister确保store始终是最新的，这样用户会话就可以在下次启动时加载了。

响应用户交互
Koober中的视图控制器在用户交互协议中声明所有可能的用户交互。类的实现在初始化时被注入。大多数用户交互都会导致对store的修改。你可以把用户交互对象想象成MVVM中的视图模型。

在Koober中，动作唯一被分派的地方是在用户交互对象中。

让我们更深入地看看在上面的登录用户交互部分提到的signinuserinteraction协议:



signinuserinteraction的实现在KooberKit的reduxsigninuserinteraction .swift文件中:


用户交互对象有两个依赖项:
ActionDispatcher将操作分派到store。
AuthRemoteAPI进行登录API调用。

首先，让我们看看ActionDispatcher。
动作调度程序是一个协议，它公开了swift store的调度动作方法:



当然，你也可以直接向store发送操作:


这是可行的，但是您必须将store注入到所有用户交互对象中。你不会想让他们访问store的所有方法。

相反，用户交互对象调度操作使用dispatcher像这样:



接下来，让我们看看reduxsigninuserinteraction是如何在用户中签名的:



签到视图有三种主要状态:
正在进行登录请求。
登录请求成功完成。
登录请求完成，但失败。

首先，登录方法调用indicateSignIn()，它分派一个SigningIn动作。这表明请求正在进行中，用户界面可以显示微调器并禁用用户交互。

接下来，用户交互对象使用远程API对用户进行签名。

如果请求成功，用户交互对象将分派一个包含新UserSession对象的SignedIn操作。该应用程序取消登录页面和过渡到地图。如果请求失败，用户交互对象将发送包含错误消息的SignInFailed。用户界面可以显示错误消息，隐藏微调项并启用用户交互。

渲染更新
动作描述状态更改，让我们看看是什么组成了一个动作:



SignInActions中的每个操作都是一个可选的包含数据的结构。
SigningIn动作只描述一个新的应用程序状态，但不需要任何额外的数据。
SignedIn动作将应用状态更改为“Signed In”，并包含一个UserSession对象。

动作本身不能改变store的状态。它们需要先通过reducer函数。reducer接受当前状态和一个动作，并返回一个新状态。

接下来，让我们看看签到reducer:





签入reducer接受一个动作和当前的SignInViewControllerState，并返回一个新的SignInViewControllerState。如果不存在SignInViewControllerState，则reducer使用默认状态。

对于SigningIn操作，reducer修改SignInViewControllerState上的变量以禁用用户交互，并将signInActivityIndicatorAnimating值设置为true。

一旦reducer返回，store更新它的状态。然后，登录视图控制器中的可观察对象被触发，用户界面更新。

Redux的循环完成了!您已经看到了状态更改如何作为一个动作开始，如何被分派到store，如何通过一个reducer来完成更新。

接下来，您将了解视图如何使用Redux Stroe相互通信。

视图直接通信
在Redux中，视图之间没有直接的通信。他们从同一个store观察状态，所以一个视图控制器可以通过调度一个动作影响另一个。reducer更新store可以改变状态，另一个视图控制器正在观察。

Redux架构中的视图控制器自然是纤细和集中的。它们触发动作，然后就会忘记这些动作，它们可能会或可能不会关心这些动作如何影响应用的状态。

选择我的界面
PickMeUpViewController包含了Koober应用的内容。它显示了地图，Where To?按钮和选车器。



当你请求Koober时，它也会在多个状态之间转换:


对于这个例子，让我们关注初始状态和selectDropoffLocation状态。

最初，地图显示Where To?按钮和预置打车位置。点击这个按钮，就会出现一个放置地点选择器页面，它会加载一个koober中可能要访问的地点列表。选择一个位置后，选择器关闭，地图显示所选的位置。

看看当你按下按钮时，地图是如何显示选择器的:





PickMeUpViewController被注入了一些依赖项:
每次状态改变时，PickMeUpViewControllerState可观察对象都会被触发。
pickmeupuserinteraction处理到哪里?按钮点击。
PickMeUpViewControllerFactory根据需要创建一个DropoffLocationPickerViewController。



PickMeUpViewControllerState有视图控制器需要显示其用户界面的数据。每次状态更新时，视图控制器都会将PickMeUpState映射到PickMeUpView状态，这更容易使用:


presentDropoffLocationPicker()方法创建了一个带有所有依赖项的DropoffLocationPickerViewController，并以模式显示页面。

当PickMeUpView状态从initial变为selectDropoffLocation时，这个方法被调用。状态转换在pick-me-up根视图中开始。





PickMeUpViewController用它的pickmeupuserinteraction依赖项初始化PickMeUpRootView。

当用户点击Where to ?按钮

pickmeupuserinteraction的具体实现是reduxpickmeupuserinteraction:




goToDropoffLocationPicker()调度一个goToDropoffLocationPicker动作，告诉地图转换到drop-off location picker。

接下来，操作需要通过一个reducer来更新store。




reducer通过创建一个初始的DropoffLocationPickerViewControllerState操作来处理gotodropofflocationpickerviewcontrollerstate用户的当前拾取位置，已经在store中了。然后，它将存储状态更新为. selectdropofflocation，其中包含初始的位置选择器状态。

这个过程的最后一步是让PickMeUpViewController处理状态更新:



PickMeUpViewController观察PickMeUpViewControllerState，并在每次状态改变时调用present(_:)。当状态变为. selectdropofflocation时，显示下拉位置选择器屏幕。

这是一个选择放置地点流程的图表:



让我们逐一回顾这些步骤:
pick- meup视图控制器用一个用户交互对象创建一个根视图。
pick-me-up根视图调用goToDropoffLocationPicker()在用户交互对象上，当用户点击Where To?按钮。
用户交互向store分派一个GoToDropoffLocationPicker。
store通过reducer运行操作，reducer将状态切换到. selectdropofflocation。
store通知可观察对象状态改变了。
pick-me-up视图控制器呈现出选择下拉位置拾取器屏幕。

视图层对状态变化做出反应，并且告诉用户交互对象用户交互发生的时间。该视图仅在store更新其状态时显示或取消页面。

选择搭车方式
Koober有各种各样的乘坐选择类型可供选择:
小袋鼠很小但很便宜，而且你可以带着额外的现金到达目的地!
中袋鼠很可靠，它们每次都能准时把你送到目的地。
大袋鼠是豪华的，您将体验冒险旅程中的最大跳跃距离。



在上面的pick-me-up页面示例中，您看到了从.initial到. selectdropofflocation的状态转换。在用户选择了下拉位置后，状态转换到.selectRideOption:





pick-me-up视图控制器转换到当前的下一个屏幕(_:)。对于. selectrideoption状态，它调用dropoffLocationSelected()来取消放置位置选择器，并显示搭车选项选择器。

选择骑行选项的逻辑存在于RideOptionPickerViewController中:



RideOptionPickerViewController被注入了一些依赖项:
当状态发生变化时，RideOptionPickerViewControllerState可观察对象就会被触发，并包含显示骑乘选项和显示错误的数据。
rideoptionpickeruserinteraction处理乘车选项选择。



分段控件使用RideOptionSegmentedControlState渲染骑乘选项段。

分段控制中的每个出行选项按钮都是使用RideOptionSegmentState创建的，它有一个出行选项ID，以及一些其他的元数据。

如果你想要阅读整个骑行选项段创建过程，完整的代码在Koober_iOS/iOSApp/SignedIn/PickMeUp/SelectRideOption/ RideOptionSegmentedControl.swift。

当您点击一个乘坐选项时，用户交互对象处理选择一个新的乘坐选项ID。



在RideOptionSegmentedControl中的实现是Reduxrideoptionpickeruserinteraction:


select(rideOptionID:)方法分派一个包含ride option ID的RideOptionSelected动作。每当用户点击一个新的乘坐选项时，分段控件就会调用这个方法。

在用户交互对象分派动作之后，一个reducer处理状态的变化:





rideOptionPickerReducer与当前RideOptionPickerViewControllerState一起接受一个动作。

对于RideOptionSelected动作，reducer找到匹配动作的rideOptionID的段，并将其isSelected标志设置为true。然后，它更新了该州的可选乘车细分市场的列表。

接下来，store通知订户更新的状态，这将导致RideOptionPickerViewControllerState中的Observable<RideOptionPickerViewController >被触发:



每次RideOptionPickerViewControllerState发生变化，这个状态会被映射到一个特定的RideOptionSegmentedControlState，并传递给RideOptionSegmentedControl。

更新viewState变量会导致段重新呈现，段控件会突出显示所选的骑乘选项段。

这是一个关于“选择乘坐”流程的图表:



让我们逐一回顾每一步:
搭车选项选择器视图控制器用一个用户交互对象创建一个根视图。
当用户点击一个网段时，网段控制调用用户交互对象上的select(rideOptionID:)。
用户交互对象用所选的出行选项ID分派一个RideOptionSelected动作。
store通过一个reducer运行操作，这个reducer更新每个ride选项段上的isSelected布尔值。
store通知可观察对象状态改变了。
乘坐选项选择器视图控制器重新渲染分段控制显示新的乘坐选项选择。

就是这样!当选择了一个新的乘车选项时，乘车选项段视图向商店发出信号。视图等待商店完成状态更新，然后重新呈现。

本章要点
Redux架构将您的所有应用程序的状态保存在一个单一的store。
动作描述状态变化。更改状态的唯一方法是将操作分派到存储。
Reducers是纯粹的函数，它采取一个动作和当前状态，并返回一个修改过的状态。唯一可以改变状态的地方是reducer函数。
使用StoreSubscriberRxProxy对象将你的商店订阅转换为RxSwift可观察对象。然后，您可以从视图层抽象swift存储。
使用select()方法将商店订阅集中在整个状态的各个部分上，这样可观察对象只在需要时触发。

Redux的利弊

Redux的优点
如果您遵循最佳实践，Redux可以随着应用程序的增长而扩展。将你的Redux存储状态分成子状态，只在视图控制器中观察部分状态。
描述性的状态变化都包含在reducer中。任何开发者都可以通过阅读你的reducer函数来理解应用程序中的所有状态变化。
store是整个应用程序的唯一真实来源。如果store中的数据发生了变化，那么变化将传播到所有订阅者。
跨屏幕的数据一致性对于iPad应用程序和其他在同一时间在多个地方显示相同数据的应用程序来说是很好的。
简化函数是纯函数——它们很容易测试。
总的来说，Redux架构很容易测试。你可以通过将应用置于任何你想要的应用状态来创建一个测试用例，分派一个动作并测试状态是否正确改变。
Redux可以通过使用持久化状态初始化存储来帮助进行状态恢复。
很容易观察到应用程序中发生了什么，因为所有的状态都集中在商店中。您可以轻松地记录状态变化以供调试。
Redux是轻量级的，是一个相对简单的高级概念。
Redux有助于将副作用与业务逻辑分开。
edux包含值类型。状态无法从你的脚下改变。

Redux的缺点

您需要触摸多个文件来添加新功能。
需要一个第三方库，但是这个库非常小。
模型层知道视图层次结构，并且对用户界面的变化很敏感。
Redux可以比其他架构使用更多的内存，因为store总是在内存中。
你需要小心性能，因为可能频繁的应用状态结构的深层拷贝。
如果您根据状态变化调度操作，那么调度操作可能会导致无限循环。
数据建模是困难的。Redux的好处取决于拥有良好的数据模型。
它被设计用来与像React这样的声明式用户界面框架一起工作。这可能不适用于UIKit，因为UIKit是必须的。这不是一个阻碍，只是它不是一个自然的适合。也许有一天苹果会给我们一个声明性的、swift编写的UIKit。
因为整个应用程序的状态是集中的，所以可以有相互依赖的reducer。这就消除了模型/屏幕/组件状态的模块化和封装性。因此，重构组件的状态类型可能会导致其他地方的编译器问题，这是不好的。如果你组织你的reducers只知道一个模块的状态，你就不会遇到这种情况。但是，这并不受体系结构的限制，因此它取决于每个人的意识。

下面干什么
Koober是一个生产应用程序，在样例项目中还有很多代码需要探索。
这里有一些地方可以看看:
在“pick-me-up”界面中，按照请求搭车的路径进行操作。在选择骑行选项并确认骑行请求后，应用程序会从sendingRideRequest(NewRideRequest)状态转换到PickMeUpViewController中的.final状态。 在Koober_iOS/iOSApp/SignedIn/PickMeUp/ PickMeUpViewController.swift中开始用户界面的转换。 然后，探索减速机如何处理KooberKit/UILayer/Features/Running/Features/ SignedIn/Features/ Features/PickMeUp/Redux/PickMeUpReducer.swift中的ConfirmedNewRideRequest和NewRideRequestSent动作。
Koober应用程序打印出控制台中每一个分派动作的信息。
在KooberKit/Reusable/ReSwiftDiagnostics/ ActionPrinterMiddleware.swift中查看这是如何实现的。它用于在Koober_iOS/ iOSApp/KooberAppDepedencyContainer.swift中设置store。


第七章 架构：元素1   By Josh Berlin & René Cacheaux

这一切都要追溯到2013年，当时我们在相互移动(Mutual Mobile)工作，这是一家位于德克萨斯州奥斯汀的移动开发公司。该公司要求我们飞往纽约，与谷歌的iOS团队合作。我们俩立刻说:“好的!”

我们不知道会发生什么。谷歌当时并没有雇佣“iOS工程师”，并希望他们的工程师根据项目的不同切换编程语言。团队中的大多数人都有强大的Java背景，并专门为这个项目学习了Objective-C。他们对iOS SDK的了解以及Objective-C的细微差别给我们留下了深刻的印象。虽然我们能够教他们Core Animation之类的东西，但他们也能够教我们软件开发的整体知识。

他们的Java背景带来了一个根深蒂固的想法，即每个项目都需要依赖注入。当时，甚至是今天，在iOS项目中使用依赖注入的情况都很少见。苹果没有内置的框架来帮助管理依赖关系，这没有帮助。对于谷歌的工程师来说，这是荒谬的，他们决定使用一个名为Objection的第三方框架来处理项目中的依赖项。

将依赖注入到每个视图控制器允许我们模拟对象和编写单元测试。对于这个项目，每个变更请求都需要单元测试。没有例外。这与Mutual Mobile的一些较为松散的项目有所不同。但这是一次很好的告别。依赖注入和单元测试改变了我们对iOS开发的看法，激发了我们对软件架构的兴趣。

回到Austin，互助移动公司的一位开发人员成立了一个棕色包小组，以观看Robert Martin——更广为人知的名字是Uncle Bob——的视频。他的视频中充满了对软件架构的深刻见解。我们已经对建筑充满了热情，但这些视频点燃了我们的热情。

Bob叔叔从多个体系结构中获取想法，并将其分解为核心目标:关注点分离。他用这个想法创建了清晰的架构，将软件划分为包括业务规则和接口适配器在内的多个层。

与此同时，我们开始为一个主要的美国品牌开发一个全新的iOS项目。我们知道这个项目将是困难的，但我们很高兴能利用我们对建筑的新激情来帮助团队成功。客户要求我们不仅要开发一款出色的iOS应用，还要开发一个SDK，这样公司内的其他应用就可以重用该应用的核心功能。René是技术领导，知道架构将是项目成功的关键。他开始更深入地研究Bob叔叔和Micah Martin的书——c#中的敏捷原则、模式和实践——以尽可能多地吸收其中的见解。

René认为将聊天层从用户界面中分离出来的最佳方法是创建两个不同的项目:一个“核心”SDK来保存聊天代码，一个用户界面层，也就是真正的Xcode项目。这迫使我们以一种不绑定到特定聊天协议的方式来构建用户界面层，而是获取不可变的数据对象，比如聊天组或聊天消息。用户界面层并不关心它们是来自XMPP还是MQTT、消息队列遥测传输还是推送通知。

这种清晰的分离使得工程师可以同时处理聊天层和用户界面层。我们能够在不影响其他层的情况下对项目的隔离层进行快速更改。应用程序源代码中开发和使用的模式可以应用于许多其他iOS项目，结论就是运用元素。

元素

元素是一种旨在让iOS开发变得有趣和灵活的架构。元素组织您的代码库，并使您的项目易于任何人导航。这种组织方式允许你在不影响稳定性的情况下改变应用的层次。一组“元素”组成了体系结构。最酷的是，你可以选择在你自己的应用程序中使用哪个组件——你的应用程序的每一层都有一个元素，从网络到用户界面。

元素是我们对架构的看法，从行业最佳实践中获取一些东西。这个理论并不是完全原创的，因为它是根据我们的经验而得出的。这一系列元素是通过将这些最佳实践与我们的理念相结合而创造出来的，并且随着更多架构进入iOS世界而不断发展。

组织是构建良好项目的关键。特定的逻辑应该很容易找到。文件和类的命名、文件夹中文件的组织、协议和对象的公共接口中的方法和属性的组织，都在一个好的体系结构中扮演着关键的角色。一个组织得更好的项目使得体系结构更加灵活。当事情有了位置，就会发现进行更改很容易，并且只需要几个文件就可以了，最好是一个文件。重点是，组织对架构很重要。

设计软件的方法不应该只有一种。软件架构是一种混合了一些科学的艺术品。出于这个原因，本章和下一章将由过去对我们有用的建筑元素组成，希望能启发您。拿你喜欢的东西，如果它有意义，就改变它。使用一个元素作为-是或使它成为你自己的。

注意:我们认为有必要强调组成元素的大多数概念都不是新的。元素是现有的最佳实践的集合，我们发现它们在设计iOS应用程序时非常有用。我们采取了这些做法，并随着时间的推移不断完善，以适应iOS开发。

元素是在一些核心底层概念的基础上设计的。让我们看看这些基本概念。

元素的基本概念

实体允许对象进行通信
每个应用程序都有一个所属领域。有的是关于地点的，Facebook是关于人的，而Uber是关于乘车的。实体代表应用程序的所属领域。如果你的应用是一个人，实体就是他们血管里的血液;它们是应用程序的DNA。实体是唯一跨架构层传播的值。通过持有这个事实,你最终构建非常灵活的软件:软件,不需要你每次都重写一切东西变化——每次产品经理提出了一个新特性,UI设计师想重塑一个页面,一个用户体验设计师想要改变流或服务器工程师想要改变一个API。

协议使软件灵活
设计优秀的协议是构建灵活软件的关键。它们定义什么，而将如何实现留给实现。如果你能清晰地定义一个应用程序的逻辑需要做什么，你就能轻松地改变它做什么。灵活性是轻松交换实现的能力。例如，你的设计师向你展示了一个全新的视觉设计——没有新的页面，没有新的功能，只是纯粹的视觉改造。如果这样的改变破坏了功能，那就有问题了。在应用程序的源代码中构建灵活性，会让你有信心进行更改，因为你知道事情不会出错。

封装允许安全更改
假设您的团队被要求将后端从一个旧的、破烂的API替换为一些新的时髦的、很酷的数据库。甚至从带有XML的SOAP风格的web服务到带有JSON的REST接口。集体的反应可能是可怕的……“我们的网络逻辑分散在整个应用中!”或者是一种兴奋……“没问题，这很容易!”如果您的团队使用封装来定义应用程序的api，那么交换网络层应该很简单。你的视图控制器不需要直接调用云数据库API，而是运行一个用例来获取或保存数据。封装允许您在远程API类中抽象所有后端逻辑。所以当你的团队被要求切换到一个新的后端时，没有人会感到惊慌。

元素
元素被分成两大类:核心逻辑和用户界面逻辑。Core Logic包含应用程序的业务逻辑，比如从API获取数据和缓存数据。用户界面逻辑包含表示逻辑，例如处理用户输入和导航。在本节中，您可以阅读每个元素的简要描述。在本章的后面，将更详细地介绍四个主要元素。

核心逻辑
实体
实体，也称为数据模型对象，是轻量级的结构化数据容器。它们除了存储值之外什么都不做。实体在整个应用程序中流动，在架构层之间传递。它们被认为是应用架构的基础。它们构成了不同对象接口之间的契约。在构建一个对象的接口时，方法通常接受一个实体对象并执行一些任务。有时，该方法返回一个新的或修改过的实体对象。在Swift中，实体最好被构建为不可变的结构。

数据存储
数据存储负责CRUD、创建、读取、更新和删除等操作。它们抽象出您想要使用的底层数据存储机制。他们可以实现Core Data, NSCoder，甚至远程数据存储网络逻辑。到数据存储的接口不公开任何关于底层实现的信息。数据存储吸收和抽出实体对象，这也是实体是应用基础的另一个原因。

远程API
远程api与网络通信。它们可以创建端点并处理响应。远程API知道你是否从像Firebase这样的云API、自定义服务器甚至硬编码的JSON文件中获取数据。视图控制器不关心数据来自哪里，通过将这些实现细节从视图控制器移到远程api中，视图控制器代码变得更可读。远程api通常用于创建和更新远程数据存储上的数据，但也可以进行任何类型的网络调用。

用例
用例代表了组成你的应用程序的用户故事。它们有项目中每个人都能理解的名称。如果您被要求描述您的用户可以用应用程序做什么，您将命名用例。用例是主要的工作单元。每当用户想要做某事时，就会创建并执行一个用例。用例将应用程序的核心逻辑与用户界面逻辑清晰地分开。

可以这样考虑:在你构建了所有的用例之后，你应该能够使用你已经定义的用例为你的应用程序构建一个命令行界面。

广播
广播员会在你的应用中发生一些事情时通知订阅者。多个对象可以订阅一个广播器。例如，您可以创建一个可重用的键盘广播器，它订阅相关的系统键盘通知。
封装此功能可以消除多个对象直接订阅Notification Center通知的需要，只需要遵循广播器的协议。

用户界面逻辑

可显示的实体
可显示的实体对象包含可呈现给用户的数据。考虑将Date对象转换为格式化的日期字符串或将epoch值转换为时间字符串。它们是由实体创建的，这些实体只包含原始数据。数据存储返回实体对象，但在提交给视图之前被转换为可显示的实体。

观察者
观察者是接收外部事件的对象。这些事件是视图控制器的输入信号。观察者知道如何订阅事件，处理事件，并将处理后的事件交付给视图控制器。例如，当键盘显示或隐藏时，KeyboardObserver可以处理来自notificationcenter的与键盘相关的通知，并知道在视图控制器上调用哪个方法。在后面的第8章中，您将了解将Notification Center逻辑抽象为一个观察者的好处。

用户界面
用户界面是……就是用户界面。这些对象允许您配置在屏幕上呈现的内容。每个视图控制器的视图都有一个用户界面协议。它们公开诸如enableSignInButton()或startedditingfirstname()之类的方法。然而，它们不会公开实现细节，比如UIKit对象。这些对象表达了您可以对用户界面进行的所有可能的更改。

交互应答器
用户界面对象知道用户何时与设备进行交互，何时点击按钮或输入文本，但不知道如何处理这些事件。这就是交互响应器的作用所在。用户界面告诉交互响应程序要做什么，交互响应程序知道如何去做。

它公开了createPostWithText()等方法，其中交互响应程序可以运行SavePostUseCase。通常，用户界面的交互响应器是它的视图控制器，但它不一定是。

元素的介绍到此结束。在接下来的四个部分中，在本章和下一章中，你将深入研究四个主要元素:用户界面、交互响应器、观察者和用例。

注意:要看到其他元素的例子，请看看本章附带的Koober Xcode项目的elements版本。如果你想看到这本书未来版本中涉及的其他元素，请在图书论坛中告诉我们。

用户界面
用户界面对象描述了应用程序中的视图。它们允许你配置和改变用户看到的和与之交互的内容。它们通常公开诸如showSuccessMessage()或displayWidget()之类的方法。然而，它们并没有暴露界面的核心。例如，它们不公开uilabel, uibutton或UITextFields。用户界面对象是用来表达用户界面能够做什么，而不是如何做。how是一个实现细节。如果你做得很好，你应该能够通过重新实现用户界面对象来实现一个全新的设计。


规范化
本节介绍如何创建和使用用户界面。它的意思是简单地解释概念。稍后您将看到代码示例。

实例化
为每个视图创建一个用户界面协议。通常每个视图控制器的根视图都有一个单一的用户界面协议。用户界面的具体实例通过对处理用户交互的对象的引用来初始化。这些被称为交互反应者。这样，用户界面就可以将其控件连接到通知交互响应器的方法。

规定
用户界面对象是在外部创建的，并通过视图控制器的构造函数或设置一个属性注入到它们的视图控制器中。
在大多数情况下，用户界面对象是视图控制器的根视图。在iOS中，每个视图控制器默认已经有一个根UIView设置为它的视图属性。通常，您希望该视图符合用户界面协议。在视图控制器的loadView()方法中，你将注入的用户界面对象设置为view属性。

使用
所有更改UI的调用都应该直接调用注入的用户接口对象。不应该直接调用视图属性。用户界面协议应该向视图公开所有可能的更改。

将用户界面对象注入视图控制器意味着你可以模拟协议对象来编写单元测试。您可以验证在正确的时间调用了正确的用户界面方法。如果你把视图设置为UIView的具体实例，这就不起作用了。

类型
用户交互协议

所有用户界面对象实现它们自己的协议，描述视图能够做什么。协议不应该公开内部如何操作的实现细节。它不应该有任何对UIKit的引用。
接下来，检查Sign-in视图的用户界面协议。


协议方法只描述视图可以做什么。render(newState: SignInViewState)描述登录用户界面不同状态之间的转换。configureViewAfterLayout()执行任何额外的配置，比如在视图完成子视图的布局后滚动。

这里的关键在于用户界面不是特定于UIView的。任何对象都可以符合该协议。您希望用户界面协议描述调用者可以对视图进行的每一个可能的配置更改，而不公开实现细节。在下面的示例部分中，您将看到这个用户界面的更详细信息。

地图用户界面就是一个很好的例子。假设你的公司正在选择Apple Maps还是谷歌Maps。6个月后，你可以完全移除谷歌地图，用苹果地图取而代之。

与其让视图控制器持有谷歌地图视图，GMSMapView，或苹果地图视图，MKMapView的具体实例，它应该持有描述地图能做的一切的MapUserInterface。这样，当你决定切换内部时，视图控制器不需要改变，只需要你的MapUserInterface的底层实现。

用户交互视图
为了在初始化时为视图控制器提供一个用户界面对象，你必须创建一个具体的UIView对象。理想情况下，你想传递一个用户界面协议对象给视图控制器，但这是不可能的。

视图控制器需要一个UIView来操作。作为一种折衷，你可以创建一个符合用户界面协议的类型别名，它也是一个UIView。这里有一个例子:


SignInUserInterfaceView是一个符合SignInUserInterface协议的UIView。传递一个SignInUserInterfaceView给视图控制器满足了视图控制器需要一个根UIView的需求，同时也提供了使用用户界面协议的灵活性。

您还可以在测试中模拟SignInUserInterfaceView，并验证视图控制器调用的正确的用户接口协议方法。

举个🌰
在本节中，您将通过一个示例来了解所有的用户界面部分在实践中是如何工作的。这个例子来自Koober的登录屏幕。



Koober的登录页面是由SignInViewController实现的。这个视图控制器将它的根视图设置为SignInUserInterfaceView，就像你之前看到的那样。因为用户界面视图符合协议，所以依赖容器应该在初始化时将具体实例注入SignInViewController。用户界面对象可以是真实视图或模拟对象，所以你不希望视图控制器内部创建那个。

视图的旅程从kooberonboarddingdependencycontainer开始，在那里初始化了SignInViewController:





以下是上述代码中的几个亮点:
makeigninviewcontroller()创建用户界面对象SignInRootView，并将其传递给登录视图控制器。稍后你会看到更详细的视图，但它是一个符合SignInUserInterface的UIView的具体实例。视图控制器不关心具体的类型，只要它能在对象上调用SignInUserInterface方法。

依赖容器方法还将ixResponder设置为视图控制器。在这里做这个而不是在视图控制器中做这个的主要原因是你传入一个SignInUserInterface和UIView对象它没有为responder的属性setter。视图控制器不能在内部设置responder对象，所以它必须在具体实例的注入时完成，SignInRootView。当用户与视图交互时，这个响应器对象得到通知。把它想象成一个委托。视图控制器只需要遵循responder协议并实现responder回调方法。您将在交互响应器一节中看到关于响应器的更多信息。

在容器中创建登录视图控制器的依赖有助于保持初始化器的整洁:





SignInViewController与SignInUserInterfaceView交互，并可以调用SignInUserInterface。即使视图控制器知道它是一个UIView，它不需要直接调用UIView。用户界面协议封装了它需要对视图进行的所有配置更改。

在loadView中，你将视图控制器的view属性设置为用户界面对象。因为userInterface是一个UIView的子类，所以这个调用很好。

更详细地看一下SignInUserInterface:


呈现(newState:)方法在登录用户界面的每个可能状态之间转换。SignInViewState包含配置用户界面的标志:
emailInputEnabled、passwordInputEnabled和signInButtonEnabled标志决定可点击元素是启用还是禁用。输入在默认情况下是启用的，而在进行签入API调用时是禁用的。
signInActivityIndicatorAnimating标志决定是否显示活动微调项。在用户点击触发API中符号调用的签到按钮后，会显示微调项。

SignInViewState非常简单。关键在于状态结构描述了视图用户界面的所有可能状态。当然，您也可以通过将状态拆分为单个方法(如enableEmailField()和disableEmailField())来实现这一点。

configureViewAfterLayout()方法让用户界面有机会在视图布局了子视图之后更新它的布局。当这个布局完成时，视图控制器会在viewDidLayoutSubviews()方法中得到通知，所以它们通常会调用configure方法。

现在，看看用户界面方法是如何在SignInViewController中被调用的:





因为视图控制器已经配置为响应ObserverForSignInEventResponder，它只是在某些事件上对用户界面进行必要的调用。当观察者通知视图控制器一个新的SignInViewState准备好了，视图控制器立即调用userInterface。呈现(newState:视图状态)。视图控制器只是传递观察者的状态，这从视图控制器代码中删除了很多逻辑。

另一件需要注意的事情是，视图控制器中没有布局代码。用户界面将其所有布局从其所有者那里抽象出来，并在其收到更改通知时处理更新。如果你需要改变用户界面内部处理键盘更新的方式，你不应该需要修改视图控制器代码。

最后，看看一些来自SignInRootView的亮点:





这个视图包含了渲染登录屏幕所需的所有UIKit元素。emailField和passwordField是UITextFields而signInButton是一个UIButton对象，都由这个视图布局。

当render(newState:)方法被调用时，每个元素上的isEnabled字段将基于状态进行更新。活动指示灯也开始或停止旋转。

键盘用户界面方法根据键盘的显示或取消来调整滚动视图的内容嵌入。这允许输入字段保持可见，而不是隐藏在键盘下。

SignInRootView代码应该很熟悉，因为它只是一个普通的UIView。最大的区别是它必须符合SignInUserInterface并正确处理那些方法。这就是用户界面部分。接下来，您将看到交互响应器是如何工作的。

交互应答器

交互响应程序处理用户交互。当用户与屏幕交互时，点击按钮或执行滑动手势，用户界面通知交互响应程序，交互响应程序处理交互。用户界面对象只知道用户何时执行交互操作。他们实际上不知道如何处理这种互动。用户界面对象不知道如何通过设计完成任何非用户界面任务。

用户界面告诉交互响应程序要做什么，而不是发生了什么。这从交互响应器中删除了任何用户界面术语。例如，响应器可能会公开一个createPost()而不是createpostbuttontap()的方法。

如果您将用户界面元素替换为登录按钮以外的东西，那么交互响应器协议保持不变。

通常，视图控制器是用户界面的交互响应器，但你可以创建一个新对象来处理用户交互，并将其注入到视图控制器中。无论哪种方式。

独立对象更容易测试，因为你不需要创建一个视图控制器。视图控制器方法需要更少的代码，因为你可以让视图控制器符合responder协议。Koober使用视图控制器方法。

应用
本节解释如何创建和使用交互响应器。它的意思是简单地解释概念。您将在下面看到代码示例。

实例化
您可以为每个用户界面创建一个交互响应器协议。然后提供交互反应者作为用户界面的参考。由于Koober视图控制器是交互响应器，它们在依赖容器中创建。

提供
用户界面对象有一个交互响应器属性，它在初始化后被设置。这样，用户界面就可以将其控件连接到方法，这些方法在用户交互时通知交互响应器。

符合交互响应协议的视图控制器与用户界面对象一起创建。在视图控制器被初始化后，它被设置为用户界面的交互响应器。

使用
用户界面直接对其交互响应程序进行调用。视图控制器只需要实现正确的交互响应器方法。

创建一个交互响应器


上面的图表显示了视图控制器是如何用用户界面初始化并设置为交互响应器的。
首先，依赖容器创建视图控制器并注入用户界面对象。
然后，依赖容器将视图控制器设置为用户界面的交互响应器。
从那时起，所有的用户交互都由视图控制器处理，它符合交互响应协议。

类型
交互应答协议
每个视图都有自己的交互响应协议。用户可以在视图上执行的任何交互都在协议中描述。它不公开关于如何实现内部结构的任何细节。协议不应该引用UIKit，也不应该提及触发用户交互的用户界面元素。
看看登录视图的交互响应器:


登录响应器协议很简单，只包含一个登录用户的方法。用户在登录页面上可以进行的唯一用户交互是在输入电子邮件和密码后点击登录按钮。

该协议有两个主要要点:
响应器不会显示关于如何发起登录的任何细节，比如点击登录按钮或点击键盘上的下一个按钮。如果重新设计用户界面，就不必更新交互响应器协议。
用户界面告诉交互响应程序要做什么，而不是发生了什么。该方法不是signinbuttontap()，而是signIn()，它告诉响应程序下一步要执行什么操作。交互响应器不关心发生了什么。用户界面负责将按钮点击和手势转换为交互响应器的可操作项。

例子🌰
在本节中，您将通过一个示例来了解交互响应器在实践中是如何使用的。这个例子来自Koober的登录页面。

SignInViewController是它的SignInUserInterfaceView的交互响应器，你在用户界面部分看到过。当用户与SignInUserInterfaceView交互时，用户界面调用交互响应器。

当在KooberOnboardingDependencyContainer中创建SignInViewController时，它被设置为用户界面的交互响应器。您已经在用户界面部分看到了初始化，但是让我们再复习一遍:





这段代码的几个要点:
唯一的交互响应器方法将用户签入。登录用例实际执行这项工作。它是SignInViewController的一个依赖项，因此交互响应器方法可以在用户准备登录时运行用例。
用户界面是对交互响应程序进行调用的对象。由于签入视图控制器在依赖项创建代码中被设置为用户交互响应器，视图控制器只需要实现协议方法。此外，由于SignInViewController只接受一个SignInUserInterfaceView，它是一个SignInUserInterface和一个UIView，你必须在具体的实例上设置交互响应器，SignInRootView。只有依赖项创建代码知道具体的类型，所以依赖项代码需要配置响应器。

用户界面将其组件连接到调用交互响应器的方法。在SignInRootView中，一个在UIButton中点击的符号会调用:



根视图在移动到窗口后立即配置目标/操作对。你也可以在视图初始化时这样做。signInButton被配置为每当点击它时调用signIn()方法。signIn()方法使用当前的电子邮件和密码输入调用交互响应器的signIn()方法。这是相当简单的代码。这里的关键是UIButton目标/动作可以切换到另一个组件上的点击手势识别器，而交互响应器不需要更改。


通常，交互响应器方法运行一个用例。就是这样。进行API调用和更改用户界面状态的大量工作在用例中处理。交互响应器实现只负责知道运行哪些用例，并运行它们。

这看起来可能过于简单，但你想从视图控制器中删除尽可能多的代码。在用例部分中，您将更好地理解在用例上调用start()之后发生了什么。

这就是交互响应器!接下来的两个元素还有很多内容要讲。在第2部分中，您将看到如何实现Observer和Use Case元素。在进入第二部分之前，请随意休息一下，伸展一下身体，喝杯咖啡或自己喜欢的饮料。

关键点
元素是一种旨在让iOS开发变得有趣和灵活的架构。一组“元素”组成了体系结构。很酷的一点是，您可以选择在自己的应用程序中使用哪些组件。
元素设计在一些核心的基础概念之上:实体允许对象通信，协议使软件灵活，封装允许安全更改。
元素被分成两大类:核心逻辑和用户界面逻辑。
本书的这个版本深入探讨了四个主要元素:用户界面、交互响应器、观察者和用例。
用户界面对象描述了应用程序中的视图。它们允许你配置和改变用户看到的和与之交互的内容。
一个设计良好的用户界面协议允许您通过重新实现用户界面对象来实现一个全新的设计。不需要改变视图控制器。
交互响应器处理用户交互。当用户与屏幕交互时，用户界面通知交互响应程序。
交互响应允许你安全地改变一个视图层次结构，而不需要改变任何视图控制器代码。这是因为交互应答者表达了用户可以用用户界面做什么，而不是特定的视图触发了什么任务。

第8章 架构：元素2

在第7章中，你学习了元素以及如何设计用户界面和交互响应器元素。在本章中，您将深入研究另外两个元素:观察者和用例。

注意:本章的Koober Xcode项目示例与第7章的Xcode项目相同。要在Koober中查看本章的内容，请打开位于第7章项目目录中的Xcode项目。

观察者
观察者是视图控制器用来接收外部事件的对象。你可以把这些事件看作是视图控制器的输入信号。观察者知道如何:
订阅事件
处理事件
将处理过的事件交付给视图控制器

例如，你正在构建一个需要响应NotificationCenter通知的视图控制器。观察者知道如何订阅通知，如何从用户信息字典中取出相关信息，还知道调用哪个视图控制器方法。然后，视图控制器将执行一些工作来响应已处理的通知。你可能会想，但是等等，从NotificationCenter添加和删除观察者真的很容易。为什么不把这段代码留在视图控制器中?接着往下看，你很快就会看到它的好处。


实例
本节解释如何创建、使用和取消分配观察者。如果这部分有点模糊，不要担心。您将在后面看到所有这些概念的代码示例。

实例化
在最简单的用法中，你为每个需要观察外部事件的视图控制器编写一个观察者类。观察者通过对触发事件的系统的引用进行初始化。这是为了当视图控制器想要开始观察时，观察者可以订阅事件。

提供
观察者被创建在视图控制器之外;也就是说，观察者被提供给他们各自的视图控制器。观察者被提供给视图控制器，要么通过视图控制器的初始化器，要么通过设置视图控制器的属性。在这一点上，视图控制器有一个对它的观察者的引用。观察者持有视图控制器想要观察的系统的引用，比如RxSwift Observables。在此阶段，观察者没有订阅任何事件。

在设置过程中，观察者需要被授予一个委托。观察者每次处理一个新事件时都会调用其委托的方法。委托，通常是视图控制器，是EventResponder类型。EventResponder是一个你专门为每个视图控制器写的协议。EventResponder协议有视图控制器实现的所有方法来响应来自不同系统的不同事件。例如，您可能有一个当键盘被解散时的方法。

使用
一旦视图控制器准备好开始观察，视图控制器可以调用一个观察者的startObserving()方法。在这个方法中，观察者订阅视图控制器需要观察的所有事件。目前，观察员正在现场观察。它们接受，处理，并向视图控制器交付事件。

当视图控制器需要停止事件到达时，可以调用观察者的stopObserving()方法。当一个视图控制器不再可见但仍然在内存中活动时，你可以这样做。如果你需要在不同的时间开始和停止观察不同的事件，你可以将一个观察者分成多个观察者。您将在变体和高级用法一节中看到一个示例。

拆除
在最简单的用法中，观察者和他们各自的视图控制器一样长。观察者和视图控制器的生存期应该匹配。为了保证生命周期，确保视图控制器是唯一持有观察者的对象。此外，观察者需要对他们的事件响应器持有一个弱引用;也就是视图控制器，以避免保留周期。

作为一个最佳实践，视图控制器应该在被ARC取消分配之前调用stopObserving()。然而，当弱引用指向观察者的事件响应器时，你可以通过调用stopObserving()在观察者内部构建一个很好的保护机制;也就是说，视图控制器消失了。你可以在willSet或didSet属性观察者闭包中这样做。您将在前面的示例代码中看到这个保护措施。

类型

观察者协议
所有的观察者都执行观察者协议。

注意:如果此名称与已存在的类型冲突，可以将其重命名为类似的名称。

视图控制器应该用观察者协议类型来注解观察者属性，而不是观察者的具体类类型。这是当单元测试视图控制器时，你不需要提供一个真正的观察者。协议是这样的:



starttobserving()和stopObserving()是视图控制器需要在任何观察者上调用的唯一两个方法。视图控制器使用这些方法开始观察和停止观察事件。

观察者事件响应器协议
当事件发生时，观察者需要能够调用他们的视图控制器上的方法来让他们的视图控制器知道一个事件发生并传递任何相关的数据。为了做到这一点，观察者持有一个弱引用到他们的视图控制器。

弱引用的类型可以是具体的视图控制器类型;然而，这给观察者访问调用所有可见视图控制器方法。相反，你可以定义一个EventResponder协议

然后你通过一个观察者的视图控制器来声明该协议的一致性。该协议包括观察者可以调用的所有方法。因为观察者需要持有这种类型的弱引用，所以这种协议类型只能由类类型来遵循。这里有一个例子:


注意事件如何来自不同的系统。例如，在上面的例子中，前一半的方法与RxSwift Observable订阅相关，后一半的方法与NotificationCenter通知相关。这很好，因为视图控制器不再需要处理不同的事件技术。这使得视图控制器更容易阅读。

另外，在上面的例子中，注意键盘事件方法是如何不传递来自NotificationCenter通知的信息字典的。观察人士知道如何提取相关信息。这真的很好，因为相关的视图控制器不再需要知道如何在信息字典中查找数据。此外，在进行单元测试时，您不必担心创建信息字典。你只需要用测试数据调用视图控制器的事件响应器方法。而且，如果以后，事件需要来自不同的系统-例如，你从CoreData切换到SQLite -你不需要改变任何视图控制器。您只需要更新观察员。

观察者类
观察者类遵循观察者协议。正如之前提到的，他们持有一个弱引用到他们的EventResponder，这通常是一个视图控制器。观察者类知道如何订阅事件、处理事件和调用EventResponder上的方法。你为每个需要观察外部事件的视图控制器实现一个观察者类。下面是一个框架实现的例子:





还记得你之前读到的保护措施吗?在上面的例子中，它是在这里实现的。每当eventResponder弱引用失效时，属性观察者调用stopObserving()。这确保当相关的视图控制器被取消分配时，观察者从事件中取消订阅。

例子
在本节中，您将浏览一个完整的示例，以便了解所有不同类型和对象是如何一起工作的。这个例子来自Koober的登录页面。

Koober的登录屏幕是由SignInViewController实现的。这个视图控制器受益于使用观察者，因为它需要观察来自不同系统的几个不同的事件。SignInViewController需要观察以下事件:

登录视图状态:RxSwift可观察对象提供了控制器的UIView状态。为了重新加载视图，控制器需要知道视图状态何时改变。当控制器看到一个新的状态时，控制器将状态对象传递给它的根UIView，这样视图就可以更新自己。
错误消息:每当发生错误时，SignInViewController需要能够呈现一个UIAlertController，比如一个错误的密码。错误消息来自RxSwift可观察对象。

通过将事件订阅委托给一个观察者，视图控制器将自己与RxSwift和NotificationCenter等技术解耦。

这使得视图控制器的代码更健壮，更干净，更容易测试。现在您已经熟悉了SignInViewController需要观察的事件，现在是时候浏览一下代码了。

为视图控制器构建观察者的第一步是设计一个带有所有事件处理方法的EventResponder协议。视图控制器应该实现这些方法。当事件发生时，视图控制器的观察者调用这些方法之一。这是你之前看到的SignInViewController的EventResponder协议:


这是完全相同的协议。在设计EventResponder协议时，避免包含任何关于事件系统的细节。例如，上面的例子避免了任何RxSwift类型和来自NotificationCenter的概念，例如用户信息字典。我们的目标是设计一个真正干净的协议，尽可能少地依赖于它。这是很重要的，因为EventResponder协议的要点是将视图控制器从事件系统解耦。

这是事件响应器。一旦你设计了你的视图控制器的EventResponder协议，你可以在视图控制器中实现类似如下的协议方法:



不要太担心这些方法是如何实现的。视图控制器响应这些事件就像任何其他视图控制器一样。重要的一点是视图控制器不再需要知道如何从特定的技术和系统接收事件。

随着EventResponder协议的设计和协议在视图控制器中实现，下一步是查看SignInViewController的观察者类，ObserverForSignIn:









以下是在上面的例子中值得强调的一些事情:
这个类符合你在本章前面看到的Observable协议。回想一下，这个协议允许关联的视图控制器启动和停止观察。
这是一个存储属性，它保存了一个到观察者关联的视图控制器的弱引用。属性的willSet闭包确保观察者在事件响应器出现时取消订阅事件;也就是说，视图控制器被取消分配。该属性是用ObserverForSignInEventResponder协议类型标注的类型。协议限制了观察者可以调用哪些视图控制器方法。如果你愿意公开所有的视图控制器方法，你可以放弃设计EventResponder协议，而只是在观察者实现中使用视图控制器具体类型。尽管，如果你需要单元测试观察者，EventResponder协议是有帮助的，因为你不需要实例化一个真实的视图控制器。你可以向观察者提供一个假的实现。
因为视图控制器应该控制观察何时开始和停止，观察者类不能在初始化期间立即订阅事件。由于这个原因，观察者类必须保留对它们所观察的系统的引用。在这个例子中，这个观察者观察来自RxSwift Observable的事件。这个观察者的实现必须抓住Observable，以便在以后的某个时间点订阅和取消订阅。有些系统，比如NotificationCenter，为添加观察者提供了全局默认单例。在这些情况下，观察者类不需要持有任何东西。
isObserving computed属性有助于避免意外地多次订阅同一个事件流。starttobserving()在订阅任何事件之前检查这个值。
应该用需要观察的系统初始化观察器。在这个例子中，这个观察者是用RxSwift Observable初始化的。
这是Observer协议的startObserving()方法实现。这个特定的实现确保观察者对事件响应者有一个引用;也就是视图控制器。然后，该方法订阅了来自同一个RxSwift Observable的两个不同的数据模型。最后，该方法开始侦听来自NotificationCenter的两个不同的键盘通知。
这是Observer协议的stopObserving()方法实现。在这个例子中，这个方法取消了RxSwift Observable的订阅，并删除了自己作为NotificationCenter观察者的身份。
这几行代码指出观察者通过事件响应器协议调用视图控制器的位置。注意观察者在调用视图控制器之前是如何处理来自RxSwift Observable和来自NotificationCenter的数据的。观察者是一个很好的地方，可以隐藏任何特定于事件系统的逻辑，比如NotificationCenter通知对象。

实践这个模式的最后一步是向视图控制器添加代码来启动和停止观察。

观察者被提供给视图控制器，而不是视图控制器实例化他们的观察者。这是因为视图控制器不需要知道如何获取初始化观察者所需的事件系统对象。

视图控制器应该有一个观察者属性来保持他们的观察者对象。视图控制器可以在适当的时间点调用startObserving()和stopObserving()。

下面是它在SignInViewController中的工作方式:







这段代码相当简单。所有关于RxSwift和NotificationCenter的讨厌的细节都不在这个视图控制器中。因为代码很容易阅读，所以没有必要一步一步地遍历它。最重要的一点是，SignInViewController不知道观察者的具体类类型。注意observer属性是如何用observer而不是ObserverForSignIn进行类型注释的。这允许你在单元测试SignInViewController时使用一个假的Observer实现。

下面是在makeSignInViewController中创建和注入ObserverForSignIn的步骤:
这个观察者是用RxSwift Observable创建的。这个可观察对象携带了所有SignInViewController需要的状态更新。
观察者被注入到一个新的SignInViewController中。回想一下，SignInViewController初始化器的观察者参数是用observer类型注释的，而不是用ObserverForSignIn。
每个观察者都需要一个eventResponder。事件响应器协议几乎总是由视图控制器实现的。在这种情况下，signInViewController被设置为观察者的eventResponder。
这就是在任何代码库中构建、创建和使用观察者所需的所有代码。本节介绍基础知识。还有许多其他方法可以设计观察者。接下来，您将学习所有的变化和高级用法。

变化和高级用法

观察者所看到的远不止这些。在本节中，您将探索实现观察者的更多方法。

为每个视图控制器构建多个观察者

为每个视图控制器构建一个观察者类是简单和直接的。但是，在某些情况下，您可能更愿意将一个观察者分解为多个观察者类。

有时，您可能需要在不同的时间开始和停止观察不同的系统。例如，当一个视图控制器离开屏幕时，你可能想停止观察UI相关的事件，同时继续观察非UI相关的事件。为此，您需要构建多个观察器。如果您不需要在不同的时间开始和停止观察，您可能仍然希望构建多个观察器。一个观察者类可能会很长。在这些情况下，最好为独立的事件系统构建独立的观察者。

为了说明这个模式，下面的代码示例演示了如何将前一节中的observer分解为两个observer: SignInViewControllerStateObserver和SignInKeyboardObserver。

首先，ObserverForSignInEventResponder需要被分离成以下两个协议:



这些协议比单个的ObserverForSignInEventResponder要好，因为每个协议只负责一种类型的事件。SignInKeyboardObserverEventResponder处理键盘事件，SignInStateObserverEventResponder处理状态变化事件。

在确定了事件响应者之后，下一步是查看单独的观察者实现:SignInKeyboardObserver和SignInStateObserver。









这些观察者的实现直接来自于ObserverForSignIn。因为每个观察者只处理单个事件系统，如RxSwift或NotificationCenter，这些观察者类比前一节中的单个观察者更容易阅读。这是将观察者分解成多个类的一个很好的优点。

现在，我们来看看SignInViewController是如何接收和使用两个观察者实例的:






这个SignInViewController的实现和以前差不多，除了这个版本管理两个观察者实例而不是一个。以下是一些可以快速浏览的东西:

视图控制器的初始化器有两个观察者。一个用于观察键盘，另一个用于观察视图控制器和视图状态的变化。注意，与前面一样，这两个参数是如何使用Observer协议而不是它们的具体类型进行类型注释的。
视图控制器需要两个属性来保存每个观察者实例。
这是与上一个实现的主要区别。因为观察是用独立的观察者构建的，这个视图控制器现在可以在不同的视图控制器生命周期方法中开始观察状态变化和键盘事件。
在viewWillDisappear期间，两个观察者都停止了。

好了，这就是大部分的例子。最后要看的是KooberOnboardingDependencyContainer是如何用两个观察者来注入SignInViewController的:




这个版本的依赖容器的主要区别在于工厂方法需要创建、注入和连接两个观察者，而不是一个。一些快速的亮点:

创建了两个观察者。
观察者被注入到一个新的SignInViewController中。
每个观察者都需要对事件响应器的引用。SignInViewController符合两个事件响应器协议，因此两个观察者都被赋予SignInViewController作为事件响应器。

就是这样!将一个单一的视图控制器观察者分解成一个单一的责任观察者需要更多的工作，但是你会得到一个更干净和更容易阅读的代码库。现在你已经看到了这些较小的单一责任观察者，你可能想知道你是否可以构建一个观察者，可以被多个视图控制器重用。这是下一个。

构建可重用的观察家

如果你发现自己一遍又一遍地写同一个观察者呢?Cocoa Touch中许多生成事件的系统本质上都是通用的。你写的订阅和响应这些事件的代码实际上是相同的，不管你在构建什么视图控制器。对于这些情况，你可以写一个通用的观察者，你可以在任何视图控制器中重用它。观察键盘事件就是一个很好的例子。接下来，您将看到一个通用键盘观察器的示例实现。

第一步是设计一个事件响应器协议，任何视图控制器都可以遵循它来响应键盘事件。但有一个问题，Cocoa Touch没有键盘用户信息数据类型。那么，如何为诸如keyboardWillChangeFrame之类的方法设计协议呢?

最简单的事情是将用户信息字典传递给视图控制器，但是观察者模式的目标之一是将这种责任和复杂性从视图控制器中移除。您可以通过设计自定义数据类型来携带通知值来完成这种责任删除。首先，你将探索这个自定义KeyboardUserInfo结构类型:





KeyboardUserInfo是一个纯数据类型，用一个Notification对象实例化。在初始化期间，KeyboardUserInfo从通知的用户信息字典中提取所有值，并在其自己的属性上设置这些值。因为用户信息字典可以是nil，而且字典可能缺少键值对，所以初始化式是可失败的。存在这种数据类型的原因是为了为键盘事件设计一个事件响应器协议。这个事件提供程序协议是什么样子的?



该协议对Cocoa Touch定义的每种键盘通知都有一个方法。这非常简洁，但是您通常只需要为其中的一些方法编写代码。所有这些方法都是必需的。你不会想在每个视图控制器中实现每一个这些方法。为了解决这个问题，我们可以让这个@objc协议成为可选的方法，或者我们可以写一个带有空方法的协议扩展。第二个选择更适合Swift。让我们看看第二种选择。下面是协议扩展的样子:





有了这个扩展，任何对象都可以符合KeyboardObserverEventResponder无需实现所有所需的方法。太棒了!
这是事件响应器，下一个是观察者实现:









这个观察者的实现方式与您目前看到的所有其他观察者完全相同。这里的新特点是观察者如何以一般方式响应键盘通知。所有通知响应方法都遵循以下模式:

每个响应方法都知道如何处理特定类型的键盘通知。因此，首先，该方法确保传入的NotificationCenter通知是预期的类型。
然后，每个方法都尝试用通知对象创建KeyboardUserInfo。因为KeyboardUserInfo的初始化式是可失败的，所以该方法需要能够处理初始化错误。您可以用许多不同的方式处理错误。在这个例子中，如果KeyboardUserInfo的初始化器失败，该方法会在调试构建时崩溃，并在发布构建时返回，因为这里的错误是不可能的。
使用KeyboardUserInfo对象调用事件响应器。

您可以实例化、注入和连接这个观察者，就像您在前面的例子中看到的那样。唯一的区别是这个观察者不是为特定的视图控制器设计的;也就是说，你可以实例化多个实例供不同的视图控制器使用。

注意:使用KeyboardObserver实现会增加一点Objective-C方法调用的开销。这是因为KeyboardObserver订阅了每一种键盘通知，即使相关的视图控制器只实现了KeyboardObserverEventResponder方法之一。在大多数情况下，这可能是微不足道的。然而，这是需要了解和衡量的东西。

这种可重用的观察者模式适用于大多数情况。然而，在一些对性能敏感的情况下，您可能需要实现单实例多播观察者。在下一节中，您将了解更多相关内容。

建立多播观察员
在这种情况下，你在屏幕上有大量的视图控制器，它们都在监听来自同一个可重用的观察者类的相同事件，你的应用程序可能有大量的观察者实例都在监听完全相同的通知或事件。在罕见的性能敏感环境中，这可能是个问题。要解决这个问题，您可以通过实现多播模式来实现更复杂的可重用观察者。

介绍多播观察者的实现超出了本书的范围。但是，通过搜索“多播委托Swift”，你可以很容易地在网上找到许多多播对象的例子。要点是多播观察者只实例化一次。它们只订阅一次通知或事件，并允许多个事件响应器委托。这比前面的例子更有效，因为所有的通知或事件只由一个观察者处理一次，而不是让几个观察者实例都订阅和处理相同的通知或事件。如果您采用这种方法，请确保密切关注内存管理问题。

组合多个观察者
假设你在一个视图控制器上工作，你设计了四个不同的观察者。你计划在同一时间调用开始观察和停止观察所有四个观察者。在视图控制器中创建四个观察者属性并调用这些方法是不方便的。一定有更好的办法。好消息是，Observer协议可以很好地用于合成。下面是一个观察者合成类的实现示例:




很简单,对吧?注意这个实现本身是如何成为一个Observer的。另外，请注意这个观察者是如何不管理任何事件响应者的。使用此模式时，您需要将事件响应器连接到每个单独的观察者，而不是组合。很快，您将看到一个如何创建组合和如何连接事件响应者的示例。

当视图控制器需要管理大量的观察者时，你可以使用这个实现。这个模式只适用于同时开始和停止观察的观察者。

那么实例化一个观察者的组合呢?这里有一个例子:





一步一步地看代码:
创建观察者。
观察者被打包成一个组合。
组合被注入到视图控制器中。
单独的观察者被赋予signInViewController作为事件响应器。

这真的简化了视图控制器的事情，因为现在只需要管理一个Observer。视图控制器不知道它给出的观察者是一个组合。视图控制器只知道它需要遵循多个事件响应器协议。这就是观察者组成。接下来是将事件响应者连接到观察者上的一个小改动。

用事件响应器初始化观察者
您可能已经注意到的一件事是，所有观察者的事件响应器属性都是可变的，而不是私有的。如果在你的代码中，你遵循例子中显示的依赖容器工厂方法模式，这不是一个大问题，因为视图控制器没有访问观察者的事件响应器属性。然而，你不必使用依赖容器模式来使用这个Observer模式。所以，如果你发现自己处于这种情况，并担心事件响应器被意外更改，这里有一个不同的方法，你可能更喜欢:




像所有的软件工程决策一样，这种方法也有权衡。这种方法保证了事件响应器不能被其他对象更改。这是很好的。另一方面，视图控制器变得有点复杂和混乱。这是因为你需要给观察者的初始化器一个事件响应器。事件响应器，在大多数情况下，是视图控制器。这是第二十二条军规，因为视图控制器的初始化器想要观察者。你不能在没有视图控制器的情况下创建观察者。解决这个问题的唯一方法是从视图控制器的初始化器中移除观察者参数，并使视图控制器的观察者属性可变和可选:



因为这增加了一点复杂性，我倾向于允许事件响应器在观察者中是可变的，而不允许视图控制器知道具体的观察者类型，这样视图控制器就不能改变观察者的事件响应器。最好的方法是尝试这两种变体，看看哪一种最适合你的代码库。

以上总结了所有Observer变体和高级用法。现在，您已经准备好进入代码库并尝试其中的一些技术了。如果你想了解这个模式的好处，并了解Josh和我最后是如何使用这个模式的，请继续阅读。

什么时候用它
当视图控制器需要更新其视图层次结构以响应外部事件时，Observer元素是完美的;也就是说，事件不是由视图控制器自己的视图层次结构发出的。如果你采用单向的方法，你所有的视图控制器可能都需要一个观察者来监听视图状态的变化。即使你的视图控制器只是观察一个Core Data查询来更新他们的用户界面。

注意:如果你发现自己在你的事件响应器方法中执行了副作用，例如网络或持久性，考虑将副作用触发逻辑移到你的内容视图控制器之外，并移到更高级别的对象，如容器视图控制器或任何应用程序范围内的对象。在事件响应器方法中执行副作用通常表示视图控制器正在执行它们不需要负责的工作。

为什么要用元素

观察者帮助保持你的视图控制器小而轻。它们从你的视图控制器中删除了很多特定于技术的样板。这最终使你的视图控制器更容易阅读和推理。使用观察者，任何开发者都可以在不知道NotificationCenter、RxSwift、swift store订阅等细节的情况下读取视图控制器。任何读取视图控制器的人都可以通过检查事件响应器方法清楚地看到所有进入视图控制器的外部事件。

此外，Observer元素允许你重构信号的来源，而不需要改变视图控制器代码。

Observer元素允许一个人处理观察逻辑，而另一个人处理视图控制器对事件的响应，从而帮助团队并行化工作。

不仅如此，观察者让你的视图控制器更容易进行单元测试。你的测试可以简单地直接调用由视图控制器实现的事件响应器方法，而不必通过NotificationCenter、RxSwift等。


你的测试可以通过注入一个假的Observer实现并通过这个假的Observer传递对视图控制器的调用，或者，通过注入一个无操作的Observer并直接调用视图控制器方法来实现。

Observer元素是一个很好的简单模式。它可以帮助您清理代码，而不需要阅读其他书籍或了解任何高级技术。试试吧，让我们知道进展如何。

起源
观察者元素并不是一个新概念。它是1994年由Erich Gamma, Richard Helm, Ralph Johnson和John Vlissides合著的著名四人组著作《Design Patterns: Elements of Reusable Object-Oriented Software 》中解释的模式之一。

Josh和我开始使用这个模式时Objective-C是唯一的iOS语言那时你必须确保在视图控制器被释放之前取消订阅NotificationCenter通知。

每次我们在视图控制器中添加一个新的通知订阅时，我们的每个团队成员都会非常紧张，因为如果我们忘记取消订阅，我们很容易使应用崩溃。

所以我们想，为什么不把所有这些逻辑放到另一个类中这样视图控制器就只需要调用一次unsubscribe这样我们就可以很容易地取消订阅所有相关的事件?我们还需要观察器来监听数据模型中的变化，以便向视图呈现更新。我们正在为一个连接到实时网络套接字的聊天应用程序构建一个集合视图。我们需要一个对象在视图控制器和网络之间，来管理背压。

在构建一个观察者之前，我们用过多的动画重载了UICollectionView。构建一个观察者可以帮助我们控制何时将数据更改发送到集合视图。在实现了几个特定于视图控制器的观察者之后，我们很快意识到使用观察者的所有其他好处。所以，它很早就成为Elements的一部分。

这就是观察者元素。它可以单独使用，也可以与任何其他元素结合使用。接下来，你将阅读关于UseCase元素的所有内容，以及用例如何帮助保持视图控制器保持良好和轻便。

用例
用例是知道如何执行用户需要的任务的命令模式对象。用例清楚以下内容:
在用户任务中执行每一步需要哪些对象。
完成用户任务需要哪些步骤。
如何在对象依赖项之间进行协调以完成用户任务。
如何管理用户任务中I/O步骤的异步特性。

用例封装了所有的对象依赖关系以及对象依赖关系中的所有业务流程。例如，用例知道需要哪些对象来为特定的用户任务执行网络和持久化任务，比如喜欢一个帖子、登录、导航到一个屏幕，等等。

实例
在本节中，您将从高层次上学习如何创建、注入、使用和取消分配用例对象。这部分是纯理论的。如果它有点模糊，不要担心，您将在后面详细介绍许多不同的代码示例。在阅读代码示例时，该理论将帮助您快速上手。

实例化
每次应用程序需要执行用户任务时，都会创建用例。例如，Twitter应用程序将在用户每次点击一条tweet的“喜欢”按钮时创建一个新的LikeTweetUseCase实例。用例通常由视图控制器创建和启动，以响应用户与UI的交互。然而，你也可以创建并启动一个用例来响应任何系统事件;也就是说，用例不仅仅是为了响应UI事件。

在最简单的用法中，可以用四种不同类型的对象创建用例:
输入数据:输入数据是执行由用例实现的用户任务所需的数据。例如，如果用例对用户进行签名，则用例将使用用户名对象和密码对象创建。在前面的Twitter示例中，将使用用户喜欢的tweet的ID创建LikeTweetUseCase。

副作用子系统对象:这些对象执行某种类型的I/O，比如网络或持久性。副作用对象允许用例改变外部世界的状态;也就是说，在用例之外，在启动用例的对象之外。

纯业务逻辑对象:在用例中，您可能需要执行一些纯业务逻辑，比如用户输入验证。这些纯业务逻辑对象执行不改变外部状态的确定性任务。


进度闭包:最简单的用例使用背后的模式是一种命令式的、双向的方法。在这种用法中，启动一个用例的对象，通常是一个视图控制器，可能想知道用例何时开始，何时取得进展，用例何时完成它的任务和/或任务是否成功完成。你可以设计用例初始化器来接受闭包，这些闭包可以被调用来指示用例的开始、进展和完成。

规定

因为用例是按需创建的，所以无论何时您需要执行用户任务，它们都不能被注入到其他对象中。假设你在为设置屏幕构建一个视图控制器。视图控制器需要能够在用户每次切换设置时创建一个新的用例。因此视图控制器不能被注入一个单一的用例实例，因为视图控制器可能需要创建多个实例。

解决方案可以像让视图控制器调用用例初始化器来创建新的用例实例一样简单。但有一个问题。用例初始化器需要视图控制器可能没有的副作用子系统对象。

一个简单的解决方案是将这些副作用子系统对象注入到视图控制器中。这样，视图控制器可以把那些对象传递给用例初始化器。这是可行的，但在实践中，这个解决方案会使视图控制器初始化器膨胀。如果一个视图控制器需要能够创建三个以上的用例，视图控制器的初始化器现在需要为所有用例需要的所有不同依赖项提供参数。

实际上，视图控制器不依赖于这些对象。用例依赖于这些对象。你可以用用例工厂来注入视图控制器，而不是将依赖注入到视图控制器中。这是下一个。

用例工厂知道如何创建一种用例类型。你将工厂注入到任何需要实例化用例的对象中。您为需要创建的每种用例类型注入一个工厂。

工厂可以是闭包，也可以是对象。要用工厂创建一个用例，您需要用例所需的输入数据和进度闭包来调用闭包或方法。基本上，除了用例的对象依赖项(比如副作用子系统对象和纯业务逻辑对象)之外，您可以使用所有的东西来调用工厂。

你可以用用例工厂注入视图控制器。然后，视图控制器可以在需要启动用户任务时调用工厂。这种方法解决了注入视图控制器与所有用例依赖关系的问题。

如果你正在使用用例并遵循第四章“对象和它们的依赖”中的依赖注入模式，你可能已经有了你需要的所有用例工厂。在下面的示例部分中，您将看到如何使用依赖注入容器作为用例工厂。

应用
用例非常容易使用。一旦您创建了一个用例，您只需要启动它。它类似于创建和恢复URLSessionDataTasks的方式。

如果您提供了进度闭包，用例将在执行期间调用进度闭包。因此，例如，如果你需要在用例开始时启动一个活动指示器，你可以将活动指示器启动逻辑放在你提供给用例工厂的onStart闭包中。

移除
这部分有点复杂。理想情况下，用例在需要时创建，在完成时释放。实现这个的最简单的方法是让视图控制器，或者任何开始用例的对象，在一个可选的存储属性中保存每个用例实例。当一个用例完成时，视图控制器可以清空这个属性。

在下面的代码示例中，你会注意到用例不是由视图控制器持有的。用例被创建并开始。看起来ARC应该释放用例。

然而，在用例完成运行之前，这些用例将保持在内存中。用例仍然被分配，因为用例示例被承诺保存在内存中。用例是使用PromiseKit承诺实现的。

这很重要，因为你可以使用任何你喜欢的异步技术，比如完成闭包，RxSwift单身者，等等，来协调一个用例内的工作。因此，您使用的技术可能需要一种不同的方法来管理用例的对象生存期。

类型
是时候从理论过渡到代码了，这一节将介绍为了构建、创建和使用用例对象而声明的主要类型。

用例的协议
用例由一个非常简单的协议表示:


该协议只有一个启动方法。开始方法实现用例要做的所有工作。

您可能想知道为什么只需要一个方法就需要一个协议。在编写单元测试时，用例协议非常有用。该协议允许您在运行单元测试时将真实的用例实现与伪实现交换。该协议还允许你对视图控制器隐藏具体的用例类型，或者对需要启动用例的任何其他对象隐藏具体的用例类型。

swift枚举结果
对于最简单的用法，用例报告它们的结果。结果是一个很好的方法来报告成功或失败在一个干净的方式。结果从Swift 5开始包含:



用例结果类型别名
因为Result是泛型的，在类型注释中专门化enum是不方便的。特别是在闭包类型中，因为类型签名变得非常长。类型化，就像下面的一个，帮助保持代码行短小精悍:


要遵循这个模式，为每个用例类声明一个UseCaseResult类型别名。下面将看到的例子中，SignInUseCase使用了上面的例子。

用例类
下面是一个用于将用户登录到Koober的示例用例实现的框架:




以下是上述实现的不同部分:
用例就是类。它们应该使用引用语义，因为每个实例代表了用例的一个特定运行。同样，用例类应该符合UseCase协议。
这些存储的属性保存了用例初始化器中提供的输入数据。
这些存储的属性包含副作用子系统对象。使用协议类型对这类对象进行类型注释是一种很好的实践。您通常不希望由于副作用对象实现更改(例如网络堆栈更改)而不得不更改用例的实现。
下面是用例用来报告进度的进度闭包。在这个例子中，当用例开始和用例结束时，用例可以运行一个闭包。如果您有一个长期运行的用例，您可以添加另一个闭包来报告正在进行的进度。注意onComplete闭包是如何使用之前的SignInUseCaseResult类型别名的。
初始化器具有用于运行用例所需的所有数据和对象的参数。如前所述，用例初始化器最好由用例工厂调用。同样值得注意的是progress闭包参数上的可选类型。这些是可选的，方便对象启动用例。有时候，这些对象不需要在progress闭包中做任何工作。所以不需要它们是很好的。
这是来自UseCase协议的start方法的实现。您将很快看到这个方法的完整实现。此代码示例旨在说明用例的剖析。在start开始任何工作之前，它执行一个线程检查，然后调用onStart闭包。为了简化线程模型，像这样的用例可以被要求从主线程中使用。不用担心，用例所做的所有工作都不在主线程中。本例将主线程简单地用作协调队列，用于在副作用子系统之间传递数据。稍后将详细介绍线程模型。

每个用例应该表示用户可以解释的一些工作。您应该能够为产品待办事项列表中的每个用户描述设计一个用例。为非常小的技术类型的任务创建用例是非常诱人的。

在实践中，这些小型技术任务最好通过可组合的异步方法建模。当您将用例集中在用户任务上时，用例就变得非常容易推理，也非常容易与他人讨论。

用例工厂类型别名
在下一节中，您将介绍的登录示例中，当用户点击登录按钮时，SignInViewController需要能够创建一个用例。SignInViewController使用用例工厂闭包创建一个用例。闭包的类型太长，不能使用内联。这个用例工厂typealias解决了闭包类型长度问题:



注意工厂闭包是如何为用例需要的所有东西提供参数的，除了副作用子系统对象依赖关系之外。这使得SignInViewController创建新用例变得更加容易，因为SignInViewController不需要知道如何获取对副作用子系统对象依赖关系的引用。唯一不太好的是闭包参数不能有标签。哪个对象应该放在哪个闭包参数中并不明显。您将在变体和高级用法一节中看到解决这个问题的替代方法。

注意:UseCase协议是工厂签名中的返回类型，而不是具体的SignInUseCase类类型。这样，启动SignInUseCase的对象除了start()方法之外就不能访问其他任何东西。这使您可以重构用例，而无需担心破坏其他代码。如果有必要，返回UseCase还可以让您在单元测试期间注入一个假实现。

举个例子
本节使用Koober的登录功能来演示如何构建和使用用例。Koober的SignInViewController需要一个能够尝试用用户名和密码将用户登录到Koober的用例。在Koober中，SignInUseCase实现了SignInViewController所需的逻辑。当用户点击登录屏幕上的登录按钮时，SignInViewController启动一个SignInUseCase。

正如您在前面看到的，要使用Result报告用例完成情况，您可以为每个用例声明一个用例结果类型。这有助于缩短闭包类型的签名。这里是SignInUseCase的SignInUseCaseResult类型别名:


这与之前的类型完全相同。下面是siginusecase的完整实现:




这个实现使用PromiseKit来协调异步工作。为了在用例中协调工作，您可以使用任何您喜欢的异步技术。我喜欢在用例中使用承诺，因为承诺链很容易遵循，而且默认的承诺线程行为在用例中工作得很好。以下是对上述承诺链的一步一步的解释:
首先标志着承诺链的开始。首先是完全可选的。它的存在是为了将代码整齐地排列起来，从而使代码链易于阅读。第一个闭包将返回一个Promise。
进入系统是第一个异步I/O任务。在这个步骤中，Koober调用它的远程API来检查用户提供的用户名和密码是否是有效的凭证。如果凭据是好的，远程API将用一个认证令牌进行响应。认证令牌被绑定到UserSession对象中。signIn方法返回Promise<UserSession>。从主队列调用signIn方法。真正的登录实现应该异步地执行网络工作，离开主队列。如果此操作失败，signIn将返回一个被拒绝的承诺，并且承诺链将短路到catch闭包。
如果签到成功完成，执行将返回到主队列。然后运行下一个闭包。在这一步中，从remoteAPI返回的UserSession被持久化到用户会话dataStore中。因为这个步骤也执行I/O工作，所以保存用户会话的API是异步的;也就是说，该方法返回一个promise。就像remoteAPI一样，dataStore期望在另一个队列上完成它的工作。dataStore返回的promise携带了来自remoteAPI的UserSession，所以promise链可以继续线程处理结果，直到最后一个promise链步骤。如果此步骤失败，承诺链将跳转到catch闭包。
如果一切顺利，将调用done闭包。在最后一步中，用例的onComplete闭包被一个成功的携带UserSession对象的Result调用。这就完成了承诺链的执行，因此也就完成了用例的执行。此时，promise链释放了对self的引用;也就是用例。然后ARC取消分配这个用例对象。
如果出现任何错误，则调用catch闭包。在这个步骤中，会创建一个错误，用例的onComplete闭包会被一个失败的Result调用。这就完成了承诺链的执行。用例将被ARC释放。

注意:promise链闭包捕获对self的强引用;也就是用例对象。你可能想知道这里是否存在一种记忆循环。承诺链保持用例。用例不被任何其他对象持有。承诺链也不被任何其他对象持有。因此，捕捉对自我的强引用是安全的。这个强引用是在用例运行时保持用例活跃的东西。如果引用是弱的，用例必须被另一个对象持有，比如视图控制器，是已经分配好内存的。

注意这个用例是如何不知道如何做任何特定的事情的。它将所有工作委托给其他对象。这是设计好的。为了有效，用例应该是协调不同抽象之间工作的轻量级对象。这允许您在其他用例中重用单个承诺链步骤。

一旦您在自己的项目中构建了几个用例，您可能会忍不住将用例组合或链接在一起。理论上这听起来很棒，但实际上却增加了不必要的复杂性。与其尝试将用例连接在一起，不如确定需要在多个用例中使用的步骤。将这些步骤组合成一个方法调用，然后从多个用例中调用该方法。

无论您选择使用哪种异步技术来协调工作，都可以遵循SignInUseCase中使用的相同线程模式。其思想是使用串行队列来协调异步工作。Start()首先应该创建一个串行队列。然后start()从串行队列中启动它的第一个异步任务。任务在另一个队列上运行。异步任务的结果在串行队列上返回。一旦回到串行队列，异步任务的结果将被交给下一个异步任务。如此等等，直到所有的工作都完成。

SignInUseCase使用主队列作为它的串行同步队列。这是可以的，因为协调工作不是CPU密集型的。主线不太可能停止。但是，您可以使用任何串行队列来协调用例中的工作。拥有一个标准的线程模式，比如这里使用的模式，可以消除围绕异步的很多复杂性。它还使每个人的代码更容易推理。这种模式可能并不适用于每一个单一的用例，但是，它应该适用于云连接的移动应用程序通常需要的大多数用例。

这就是用例实现。现在，是时候浏览一下创建这个用例实例所需的代码了。用例工厂类型别名是第一个要查看的地方:


这与您之前看到的类型完全相同。您需要为您构建的每个用例定义其中一个。这个类型是完全可选的。typealias只是帮助缩短类型签名。

好了，有趣的部分到了。视图控制器如何在不调用用例初始化器的情况下创建用例的

记住，用例初始化器有副作用子系统对象依赖关系的参数，视图控制器或任何需要启动用例的对象，实际上不需要有。因为用例的每个实例代表用户任务的一个调用，所以您可能需要实例化用例的多个实例。例如，在登录屏幕中，假设用户输入了错误的用户名和密码。

当用户点击Sign in按钮时，应该创建一个新的SignInUseCase。用例失败，错误报告给用户。用户纠正了一个拼写错误，然后再次点击“登录”按钮。应该创建一个新的SignInUseCase。由于这个原因，您不能简单地注入单个用例对象。因此，为了创建一个用例，一个对象需要被注入一个工厂，对象可以使用这个工厂来创建用例的新实例

记住这一点，下面是SignInViewController的相关部分:





下面是使用SignInViewController创建和使用SignInUseCases的步骤:

这个存储属性持有用例工厂闭包。这个闭包是通过视图控制器的初始化器注入到视图控制器的。这就是用例工厂类型别名派上用场的地方。如果没有类型别名，这个声明看起来像:let makeSignInUseCase: (String, Secret， @escaping () -> Void， @escaping (SignInUseCaseResult) -> Void) -> UseCase。
这是视图控制器的初始化器。用例工厂闭包在这里提供给视图控制器。
这是用户点击Sign in按钮时UI调用的方法。这就是需要创建和启动新的SignInUseCase的地方。
登录中的第一步是创建进度闭包。
然后，视图控制器使用用例工厂闭包来创建一个新的SignInUseCase，使用用户输入的用户名和密码以及在最后一步中创建的进度闭包。
最后，视图控制器启动这个用例。当用例完成时，用例调用前面创建的onComplete闭包。视图控制器可以使用onComplete闭包来知道用例何时结束，以及知道用例运行是否成功。

这从SignInViewController中移除了大量的复杂性。如果SignInViewController有更多的用户交互需要处理，那么SignInViewController的整体复杂性将被扩展到各种用例中。换句话说，所有的复杂性将被分解成几个用例对象，而不是将所有的视图控制器的复杂性转移到单个对象中，比如一个视图模型。用例的伟大之处在于，实际上您可以在任何体系结构模式中使用它们。例如，您可以在MVVM视图模型中创建并启动用例。

最后要看的是KooberOnboardingDependencyContainer如何将签入用例工厂闭包注入到SignInViewController中:




这主要有两个方面。一个是工厂方法，它知道如何使用用例的初始化器创建一个新的SignInUseCase。第二部分是SignInViewController工厂，它将第一个方法作为登录用例工厂注入到一个新的SignInViewController中。

下面是详细的步骤:
这是依赖容器中的SignInUseCase工厂方法。它接受用例所需的所有对象，除了副作用子系统对象。副作用子系统对象可以在依赖项容器中使用。
这就是工厂如何创建或获取登录用例所需的副作用子系统对象的方式。工厂使用依赖容器创建一个新的authRemoteAPI。然后，工厂获取由依赖容器持有的共享userSessionDataStore。
然后，为了调用用例的初始化器来实例化一个新用例，工厂使用从依赖容器传入的伴随副作用子系统对象的参数。
最后，工厂返回一个新的登录用例。
这是当用户导航到登录页面时，用来创建一个新的视图控制器的SignInViewController工厂。
这一步获取对用例工厂方法中的符号的引用。请注意，这是对方法的引用，而不是对象。还记得登录用例工厂参数类型是如何从SignInViewController的初始化器是一个闭包类型吗?由SignInUseCaseFactory类型别名表示的闭包类型。即使参数是闭包类型，只要方法的签名与闭包的签名匹配，方法引用也可以作为参数传入。
在这个步骤中，依赖容器的签入用例工厂方法makeSignInUseCase被注入到一个新的SignInViewController中。用例工厂方法被注入，以便视图控制器可以在视图控制器需要创建一个新用例时调用这个方法。使用这种方法，视图控制器可以创建一个登录用例，而不需要知道如何创建authRemoteAPI，以及如何获得一个共享的userSessionDataStore。这可真是太酷了!

这就是你如何设计，构建，创建和使用用例。既然您已经知道了基本的知识，那么您可以看看下一节，看看是否有任何您想要尝试的这种模式的变体。

变化和高级用法
你已经了解了将用例整合到你自己的Xcode项目中所需要的大部分内容。但是，您可能更喜欢使用一些微妙的变化。本节详细介绍了用例工厂使用协议而不是闭包类型，设计单向用例和设计可取消用例。

使用用例工厂协议而不是闭包
用例工厂闭包类型的一个大缺点是参数没有标记:



需要注释来指出每个参数应该包含什么内容。你可以声明一个用例工厂协议，而不是使用闭包类型。这需要更多的工作，并向代码库中添加更多类型，所以您可能不喜欢这种方法。这真的是偏好的问题。我喜欢这种方法，因为它使其他人更容易创建您所设计的用例。在工厂调用站点，其他开发人员可能不知道闭包类型所需的所有参数。

下面是用例工厂协议的样子:



该协议是一个简单的单一工厂方法协议。工厂方法的签名与闭包在typealias中的签名完全相同。唯一的区别是参数被标记了。

这是如何改变视图控制器的?并不多。看一看:





唯一的区别是视图控制器在工厂上调用一个方法，而不是仅仅调用工厂本身。注意在这个版本的视图控制器中，工厂方法的参数是如何标记的。这更容易写。但是读起来有点冗长。这也算是一种利弊权衡吧。

这个例子使用的不是工厂闭包类型别名，而是协议。那么，什么对象符合这个工厂协议?下面是依赖容器:



如果将协议与上面的代码交叉引用，您将注意到makeSignInUseCase与协议方法完全匹配。KooberOnboardingDependencyContainer已经符合工厂协议。这是不是很简单!

唯一需要的是协议一致性声明:


通过声明一致性，makeSignInViewController工厂方法可以将kooberonboarddingdependencycontainer作为SignInUseCaseFactory注入到一个新的SignInViewController中:



与前面的例子相比，这段代码的主要区别在于，依赖容器本身被注入到视图控制器中，而不是注入依赖容器的makeSignInUseCase方法。

类型别名和协议方法都做完全相同的事情。试试这两种方法，看看哪种感觉最好。

在启动时提供用例完成关闭

在主要示例中，登录用例的onComplete闭包是在用例初始化期间提供给用例的。你可能会觉得这看起来有点奇怪。相反，为什么不在用例的start方法中提供完成闭包呢?

这看起来确实更好:


为了采用这种方法，你需要一个不同的UseCase协议:


现在，你必须处理臭名昭著的关联类型。因为Result类型是泛型，所以需要关联的类型。每个用例实现可以有不同的成功和失败类型。因为这个版本的UseCase协议有相关的类型要求，所以下面的代码不能编译:


采用这种方法并非不可能。您需要实现一个类型擦除的AnyUseCase，以便能够将内容输入为任何类型的用例。这增加了大量的复杂性，却没有得到很多回报。浏览被删除的AnyUseCase类型超出了本书的范围。如果你想了解更多，请搜索“Swift associatedtype type erasure”。

设计混合的单向-双向用例
在主要的例子中，SignInUseCase通过onComplete闭包给SignInViewController用例结果。如果另一个对象也需要知道结果呢?SignInViewController可以通过传递结果开始与其他对象通信。然而，这并不是很好，因为对象数据流变得非常难以跟踪。这种传递对象的方法也会导致不一致的状态。正因为如此，iOS视图控制器通常会监听数据库中的数据变化。

如果你的视图控制器正在监听数据库的变化，你可能更喜欢这样设计你的用例：





这里的不同之处是Result类型不再携带成功的值。UserSession保存在数据存储中。这个实现假设对象正在侦听dataStore，以知道用户何时登录并访问用户的UserSession。这不是纯粹单向的，因为用例仍然返回一个结果给视图控制器，或者任何开始这个用例的对象。

仍然存在某种形式的双向交流。通常，代表用例进展的状态只需要一个视图控制器。在大多数情况下，在视图控制器和用例之间有一个私有的来回切换可以很好地工作。或者你可能会把所有的钱都花在单向的数据流上。接下来的两部分将演示单向用例示例。

设计支持数据库的单向用例
当您按照单向数据流模式构建应用程序时，您可以将应用程序的状态存储在数据库或类似redux的内存状态存储中。本节演示了使用数据库存储应用程序状态时的用例。
下面是一个单向版本的SignInUseCase:





首先要注意的是，所有的进度闭包都消失了。不再需要用例结果类型别名。单向用例要简单得多。
另一件需要注意的事情是，在这个用例中如何有更多的数据库任务:
第一步更新数据库中的状态，以表明用户正在登录。一个视图控制器可能正在监听数据库并使用观察来控制一个活动指示器。
如果一切顺利，用户的UserSession将存储在数据库中，并且在数据库中将签名状态设置为false。导航控制器可以监听数据库中的用户会话变化，并在保存新用户会话时自动将用户带出登录界面并进入应用程序。
如果出现错误，则错误和签到状态保存在数据库中。这部分有点奇怪，因为当错误发生时，您必须执行I/O操作，而且这需要一个新的promise链。如果数据库出了问题，除了使用assertionFailure使调试构建崩溃之外，您没有什么可以做的。如果可以从数据库错误中恢复，可以将该逻辑放在第二个catch闭包中。

这里的缺点是必须处理比以前更多的异步。另一种选择是使用类似redux的状态存储。这个例子是下一个。

设计Redux单向用例
用例在使用Redux架构模式构建的应用程序中也能很好地工作。下面是另一个版本的SignInUseCase，可以在第六章的例子项目中使用:

注:如果您想学习这个例子，并且不熟悉Redux，请参阅第6章“架构:Redux”。




与前面的单向数据库用例示例一样，所有的进度闭包都没有了。数据存储也消失了。在第6章“架构:Redux”中，数据存储监听Redux存储以持久保存用户的UserSession。因此，用例并不需要数据存储。最后，还有一种新的依赖 actionDispatcher，actionDispatcher用于将Redux操作分派到Redux存储区。

在与Redux一起构建用例时，你会注意到一件事，用例倾向于分派几个动作。例如，在上面的示例代码中:
一个动作被发送，以表明应用程序正在尝试登录用户。进度闭包被表示通过用例的进度的动作所取代。	
一旦用户的凭据通过remoteAPI成功验证，就会分派一个携带新UserSession的操作。
如果出现错误，则会发送一个带有错误消息的错误操作。


当第一次将用例应用到Redux代码库时，很容易为每个Redux操作设计一个用例。然而，用例比Redux操作粒度小得多。基于视图控制器需要做的工作而不是Redux需要更新应用状态的状态事件来设计你的用例。			
		
这个用例模式解决了Redux的一个更困难的挑战，将异步副作用I/O与动作混合在一起。你不需要处理中间件。更好的是，有了这个模式，视图控制器甚至不知道应用程序是用Redux构建的。视图控制器只知道创建和运行什么样的用例来响应什么样的用户交互。

这就总结了所有的单向变化。您可能已经注意到，到目前为止，没有一个用例可以取消。下一节将演示如何构建可取消的用例，当您希望您的用户能够取消一个正在进行的用例时，您可以构建这些用例。

注意:本章附带的Koober Xcode项目示例的Elements版本使用了Redux单向版本的用例。用例替换了Koober Redux版本中的userinteraction对象。

设计可取消的用例
通过添加一些额外的类型，您可以利用到目前为止学到的知识，将取消添加到任何用例中。首先要看的是Cancelable协议:


你需要自己声明这个协议，因为它不是Swift的一部分。就像UseCase协议一样，这个协议非常简单。它只是一个单一的方法，可以被视图控制器调用来取消正在进行的工作。cancel方法可以直接添加到UseCase中，但是每个用例都必须是可取消的。许多用例不应该取消。因此，您可以从上面声明Cancelable协议，而不是向UseCase添加cancel。

下一个是CancelableUseCase类型别名:


这个类型别名方便了对符合Cancelable和UseCase的常量和变量进行类型注释。这允许视图控制器声明一个用例工厂，例如下面的一个，它返回一个可取消的用例:


任何注入到这个工厂的视图控制器都可以创建，启动和取消一个SearchLocationsUseCase。
这是SearchLocationsUseCase的实现:






以下是上述实现可取消用例的所有附加逻辑的演练:
用例需要这个布尔存储属性来保存取消状态。用例是在未取消状态下创建的。
这实现了Cancelable协议中的cancel方法。为了避免与并发性有关的状态变化的任何问题，该方法首先检查它是否在主线程上运行。然后它将用例的状态更改为取消。这允许用例的其余部分检查用例是否被取消。
start所做的第一件事就是在用例被取消的情况下中止。这是非常罕见的。如果创建了用例，但没有立即开始，就会发生这种情况。

一旦网络连接完成，done闭包首先检查用例是否被取消。如果是这样，它将提前退出，而不发送任何操作。这种形式的取消不会停止任何正在进行的工作。它放弃了对结果的处理。如果一个用例正在执行一个长期的网络任务，您可能希望在用例的cancel方法被调用时立即停止网络。您可以通过将承诺存储在属性中并取消承诺链来实现这一点。要了解更多关于取消承诺的信息，请访问PromiseKit的GitHub仓库。

这就是如何将取消合并到用例中。这就说明了用例的所有变化和高级用法。

何时使用
大多数时候，用例是在视图控制器或视图模型中使用的。用例通常作为用户与应用程序UI交互的响应而运行。但是，有时您需要执行一些工作来响应某些系统事件，例如位置通知。您也可以为这些情况使用用例。

为什么用这个元素
用例模式是我在iOS应用开发中使用的最通用的模式之一。用例适用于几乎所有的体系结构模式。而且，它们有很多好处。

将应用程序的主要工作块分解成用例，可以让你在任何视图控制器中重用逻辑。例如，你正在创建一个社交网络应用程序，你正在创建一个LikePostUseCase来响应用户喜欢的帖子。如果你需要将like-post按钮添加到多个视图控制器中，你可以轻松地重用LikePostUseCase来运行按钮背后的逻辑。

在大多数架构模式中，工作是按屏幕而不是用例组织的。任何一个按钮背后的逻辑都与按钮所在屏幕的逻辑捆绑在一起。当你突然需要将按钮添加到另一个屏幕时，就很难再使用按钮的逻辑了。这种情况在MVC和MVVM体系结构模式中非常常见。好消息是，您可以将用例合并到这两个模式中。如果你曾经经历过大规模的应用重新设计，你就会知道这种灵活性的价值。此外，通过用例，你可以解决大量视图控制器的问题，而不用把问题移到其他地方，比如大量视图模型。

将应用程序的主要工作块分解成用例，还可以让你构建一些非常酷的功能测试。如果您需要测试特定的用户操作序列，您可以编写完整的测试套件，而不需要任何UI对象。在测试套件中，您可以实例化并运行一系列用例。因为用例是以用户任务命名的，所以这些测试非常容易阅读。

在编写单元测试时，用例也会派上用场。假设您需要确保在响应特定通知时启动一项工作。您可以利用带有假UseCase实现的单元测试，该实现公开一个属性，允许您断言是否调用了start方法。然后，为了测试行为，您可以发出通知并断言用例是由正在测试的任何对象启动的。

而且，用例模式相对简单。这很容易教，也很容易付诸实践。整合用例并不需要你重新架构整个应用。对于大多数常见的移动应用I/O任务，你最终会得到一个简单而有效的线程策略。用例还有助于简化依赖关系管理。视图控制器不需要获取对数据库和联网对象的引用。

当使用用例时，你会发现你不再需要经常更改视图控制器代码。通常当我们正在改变代码,改变一些特性而改变的特性在一个应用程序。例如,如果你改变你的应用程序使用一个新的云API或一个新的数据库,最终主要工作地点是在子系统用例和副作用的方面。

就像其他元素一样，用例允许您在团队成员之间并行开发工作。如果一个视图控制器需要三个用例，不同的开发人员可以构建每个用例。

最后但并非最不重要的是，用例可以帮助您与跨所有规程的所有团队成员交流工作。例如，您可以在每个用例的backlog中创建每个人都理解的任务。我已经看到这种交流的好处出现了好几次。就在最近，我在一个项目回顾会上，我们的产品经理引用了用例。他建议我们可以通过先发布一个用例来构建我们正在构建的库的第一个版本。当每个人都理解正在发生的工作时，团队合作就会变得更加富有成效和愉快。

起源
在阅读Robert C. Martin和Micah Martin的《Agile Principles, Patterns, and Practices in C# 》时，我第一次遇到了看起来像用例的代码。Elements中的用例模式受到了书中Payroll案例研究中给出的事务模式的启发。

自从五年前撰写本文时我们开始使用这个模式以来，Josh和我已经对它进行了很大的改进。我们首先使用NSOperations来运行我们称为Actions的东西。虽然这种模式可行，但它非常繁琐。对于每个用例，你必须实现一个Action类和一个NSOperation子类。然后，我们通过将所有用例逻辑放在每个NSOperation中来简化模式。如果你想了解这个模式，你可以看看我在2016年RWDevCon上给出的应用架构教程。当时，我们使用NSOperation，因为我们可以把操作链在一起，我们认为把用例链在一起会很方便。然而，我们使用该模式的次数越多，我们就越意识到我们从来不需要将用例串联起来。NSOperation更复杂，我们不需要。所以在2017年，我们决定放弃NSOperation并使用你在这里看到的简单UseCase协议建模用例。

如果你想看这个版本的模式，你可以观看Josh和我在2017年RWDevCon上举办的高级应用架构研讨会。在2017年和2018年，我们学习了如何使用Redux单向模式构建iOS应用程序。我们最终将模式演化为目前的形式，以便在单向体系结构中使用。如果你想通过用例了解更多关于高级单向技术的信息，你可以观看我的RWDevCon 2018教程，高级单向架构。

面向对象用例背后的思想已经存在一段时间了。要了解早期的想法，您可以阅读Ivar Jacobson的书，面向对象软件工程:用例驱动方法，出版于1992年。

元素的利弊

元素的优点
你可以合并任何一个元素，而不需要重构整个应用程序。
单个元素是简单和直观的。他们很容易学习，教授和实践。
元素只在需要时才需要构建。你不会有一堆样板代码。您也不会有任何空的代理类。例如，如果一个视图控制器不需要做任何用户发起的工作，你就不需要构建任何用例。如果一个视图控制器不需要观察任何东西，你不需要实现一个Observer类。
您可以轻松地在整个团队中分配开发工作负载。不同的团队成员可以并行构建不同的元素。
元素可以与许多其他体系结构模式一起使用。
元素帮助你单元测试你的大部分代码库，包括视图控制器，视图，观察者等。这是因为每个元素都由一个协议表示。这允许您在单元测试期间在运行时使用不同元素的伪实现。

元素的缺点
元素使用许多不同的协议。你可能会觉得你处理了太多的协议。在依赖容器代码中尤其如此。如果是这种情况，那么协议都是可选的。请随意使用具体版本。要知道，您可能会失去一些单元测试的好处。
元素将逻辑分解成相当小的块。最后你会学到很多课程。如果文件组织得不好，在Xcode项目中导航会很困难。
虽然大多数元素是从现有的思想和技术发展而来的，但是元素作为一个整体是新的，其他开发人员可能不熟悉这些模式。在撰写本文时，本书是关于Elements的唯一信息来源。

关键点
观察者是视图控制器用来接收外部事件的对象。你可以把这些事件看作是视图控制器的输入信号。
当视图控制器需要更新其视图层次结构以响应外部事件时，Observer元素是完美的;也就是说，事件不是由视图控制器自己的视图层次结构发出的。
观察者帮助保持你的视图控制器小而轻。它们从你的视图控制器中删除了很多特定于技术的样板。
用例是知道如何执行用户需要的任务的命令模式对象。
用例适用于几乎所有的体系结构模式——并且它们带来了很多好处。
大多数时候，用例是在视图控制器或视图模型中使用的。用例通常作为用户与应用程序UI交互的响应而运行。


结论
这是一段多么美好的旅程啊!从探索体系架构的重要性到深入研究依赖注入，再到比较不同的体系结构模式，您已经初步了解了使用高级技术和模式构建iOS应用程序。

通过将书中的概念付诸实践，你的代码库将变得更容易工作，你也会在编写代码时获得更多乐趣。不仅如此，您将能够快速响应需求的变化。

我们希望您在本书中看到的想法能够激励您探索和尝试不同的建筑实践，甚至可能激励您提出自己的一些想法!

如果你渴望更多与架构相关的书籍，我们推荐你阅读Design Patterns by Tutorials。另外，如果你觉得有些RxSwift代码很难理解，我们建议你看看RxSwift: Swift响应式编程。

在阅读本书的过程中，如果您有任何问题或意见，请访问我们的论坛http://forums.raywenderlich.com，并寻找这本书的特定论坛类别。

再次感谢您购买这本书。你们的持续支持使我们在raywenderlich.com所做的书籍、教程、视频和其他事情成为可能。我们真的很感激!

架构万岁!

– The Advanced iOS App Architecture team			
				

	读到这里或许你已经有所收获	，然后架构的路才刚刚的开始	，一起加油。	
大量机翻的作者-- 东阁堂主
			                                            
		



































